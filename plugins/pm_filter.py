
# Kanged From @TroJanZheX
import asyncio
import os
from PIL import Image
import asyncio
import re
import ast
import math
import random
import pytz
from datetime import datetime, timedelta, date, time
lock = asyncio.Lock()

from pyrogram.errors.exceptions.bad_request_400 import MediaEmpty, PhotoInvalidDimensions, WebpageMediaEmpty
from Script import script
# from MINNALMURALI.SCRIPT import script
import pyrogram
from info import ADMINS, ADMIN, AUTH_CHANNEL, AUTH_USERS, SUPPORT_CHAT_ID, CUSTOM_FILE_CAPTION, MSG_ALRT, PICS, AUTH_GROUPS, P_TTI_SHOW_OFF, GRP_LNK, CHNL_LNK, NOR_IMG, LOG_CHANNEL, SPELL_IMG, MAX_B_TN, IMDB, \
    SINGLE_BUTTON, SPELL_CHECK_REPLY, IMDB_TEMPLATE, NO_RESULTS_MSG, TUTORIAL, REQST_CHANNEL, IS_TUTORIAL, LANGUAGES, PREMIUM_USER, FILE_CHANNEL, FILE_FORWARD, SP
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, InputMediaPhoto, ForceReply
from pyrogram import Client, filters, enums
from pyrogram.errors import FloodWait, UserIsBlocked, MessageNotModified, PeerIdInvalid
from utils import get_size, get_poster, search_gagala, temp, get_settings, save_group_settings, get_shortlink, send_all, get_cap, get_tutorial, is_subscribed
from utils import get_size, is_subscribed, get_poster, temp, get_settings, save_group_settings, get_shortlink, send_all, check_verification, get_token

from database.users_chats_db import db
from database.ia_filterdb import Media, Media2, get_file_details, get_search_results, get_bad_files, db as clientDB, db2 as clientDB2
from pyrogram.enums import ChatType, ChatMemberStatus
from pyrogram.types import ChatPermissions
import logging

# removebg
from plugins.helpers.edit_4 import removebg_white, removebg_plain, removebg_sticker
# removebg

import os
from PIL import Image
from pyrogram.types import Message
from pyrogram import Client, filters, enums

from pyrogram.types import Message
from pyrogram.errors import MessageIdInvalid, ChatAdminRequired, EmoticonInvalid, ReactionInvalid 
from random import choice
from plugins.helpers.config import Telegram
from info import *

from traceback import format_exc
from pyrogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup
from search_engine_parser.core.engines.google import Search as GoogleSearch
from search_engine_parser.core.engines.stackoverflow import \
    Search as StackSearch
from search_engine_parser.core.exceptions import NoResultsFound, NoResultsOrTrafficError
from pyrogram import filters
from pyrogram import Client, filters, enums
from plugins.EXTRA.SearchGoogle import ikb
#######
from plugins.NEW.Welcome import spellcheck, WelDatabase
#######
from plugins.EXTRA.Date import TimeRequest
#######


from io import BytesIO
from pyrogram.filters import *
from pyrogram import Client, filters
from plugins.helpers.herokuu import app, h_conn
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from plugins.helpers.sample_config import Config

import asyncio
from asyncio import sleep
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup
from pyrogram.errors import FloodWait,UserNotParticipant
import humanize
from info import *

##### carbon #####
import aiohttp
from io import BytesIO
from pyrogram import filters



from pyrogram import idle
interval = 10


gsearch = GoogleSearch()
stsearch = StackSearch()

wlcm = WelDatabase()


async def reaction(sp):
    try:
       await sp.react(choice(Telegram.EMOJIS))
    except (
        MessageIdInvalid,
        EmoticonInvalid,
        ChatAdminRequired,
        ReactionInvalid
    ):
        pass
    return True, "Success"


async def make_carbon(code):
    url = "https://carbonara.solopov.dev/api/cook"
    async with aiohttp.ClientSession() as session:
        async with session.post(url, json={"code": code}) as resp:
            image = BytesIO(await resp.read())
    image.name = "carbon.png"
    return image








# Kanged From @TroJanZheX
import asyncio
import re
import ast
import math
import random
import pyrogram
lock = asyncio.Lock()

from pyrogram.errors.exceptions.bad_request_400 import MediaEmpty, PhotoInvalidDimensions, WebpageMediaEmpty
from Script import script
from database.connections_mdb import active_connection, all_connections, delete_connection, if_active, make_active, \
    make_inactive
from info import ADMINS, AUTH_CHANNEL, AUTH_USERS, SUPPORT_CHAT_ID, CUSTOM_FILE_CAPTION, MSG_ALRT, PICS, GRP_LNK, CHNL_LNK, NOR_IMG, LOG_CHANNEL, SPELL_IMG, MAX_B_TN, \
    NO_RESULTS_MSG, IS_VERIFY, HOW_TO_VERIFY
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, InputMediaPhoto
from pyrogram import Client, filters, enums
from pyrogram.errors import UserIsBlocked, MessageNotModified, PeerIdInvalid
from utils import get_size, is_subscribed, get_poster, temp, get_settings, save_group_settings, get_shortlink, send_all, check_verification, get_token
from database.users_chats_db import db
from database.ia_filterdb import Media, Media2, get_file_details, get_search_results, get_bad_files, db as clientDB, db2 as clientDB2
from database.filters_mdb import (
    del_all,
    find_filter,
    get_filters,
)
from database.gfilters_mdb import (
    find_gfilter,
    get_gfilters,
    del_allg
)
import logging

import logging

# removebg
from plugins.helpers.edit_4 import removebg_white, removebg_plain, removebg_sticker
# removebg

import os
from PIL import Image
from pyrogram.types import Message
from pyrogram import Client, filters, enums
from pyrogram.types import Message
from pyrogram.errors import MessageIdInvalid, ChatAdminRequired, EmoticonInvalid, ReactionInvalid 
from random import choice
from plugins.helpers.config import Telegram




logger = logging.getLogger(__name__)
logger.setLevel(logging.ERROR)



FRESH = {}
BUTTONS = {}
SPELL_CHECK = {}
GENERAT = "-1001203428484"
UPLOAD_CHANNEL = "batchfiles_store"
BATCH_LINK = "-1001203428484"

RUN_STRINGS = (
    "ğŸ¬",
    "ğŸ¨",
    "ğŸ¿",
    "â˜˜",
    "ğŸ­",
    "ğŸ",
    "ğŸ“€",
    "ğŸƒ",
    "ğŸ­",    
)
@Client.on_message(filters.group & filters.text & filters.incoming)
async def give_filter(client, message):
    try:
        await message.react(choice(Telegram.EMOJIS))
    except (
        MessageIdInvalid,
        EmoticonInvalid,
        ChatAdminRequired,
        ReactionInvalid
    ):
        pass    
    if message.chat.id != SUPPORT_CHAT_ID:
        content = message.text
        if AUTH_CHANNEL and not await is_subscribed(client, message):
            try:
                invite_link = await client.create_chat_invite_link(int(AUTH_CHANNEL))
            except ChatAdminRequired:
                logger.error("Make sure Bot is admin in Forcesub channel")
                return
            buttons = [[
                InlineKeyboardButton("ğŸ“¢ ğ‰ğ¨ğ¢ğ§ ğ‚ğ¡ğšğ§ğ§ğğ¥ ğŸ“¢", url=invite_link.invite_link)
            ],[
                InlineKeyboardButton("ğŸ” ğ‘ğğªğ®ğğ¬ğ­ ğ€ğ ğšğ¢ğ§ ğŸ”", callback_data="grp_checksub")
            ]]
            reply_markup = InlineKeyboardMarkup(buttons)
            try:
                await client.restrict_chat_member(message.chat.id, message.from_user.id, ChatPermissions(), datetime.now() + timedelta(minutes=1))
            except:
                pass
            k = await message.reply_photo(
                photo=random.choice(SP),
                caption=f"ğŸ‘‹ ğ‡ğğ¥ğ¥ğ¨ {message.from_user.mention},\n\n{content} ğ€ğ¯ğšğ¢ğ¥ğšğ›ğ¥ğ..!!\n\nğğ¥ğğšğ¬ğ ğ‰ğ¨ğ¢ğ§ ğŒğ² 'ğ”ğ©ğğšğ­ğğ¬ ğ‚ğ¡ğšğ§ğ§ğğ¥' ğ€ğ§ğ ğ‘ğğªğ®ğğ¬ğ­ ğ€ğ ğšğ¢ğ§. ğŸ˜‡",
                reply_markup=reply_markup,
                parse_mode=enums.ParseMode.HTML
            )
            await asyncio.sleep(300)
            await k.delete()
#            try:
#                await message.delete()
#            except:
#                pass

        else:

            await auto_filter(client, message)

        




@Client.on_callback_query(filters.regex(r"^next"))
async def next_page(bot, query):
    ident, req, key, offset = query.data.split("_")
    curr_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
    if int(req) not in [query.from_user.id, 0]:
        return await query.answer(script.ALRT_TXT.format(query.from_user.first_name), show_alert=True)
    try:
        offset = int(offset)
    except:
        offset = 0
    if BUTTONS.get(key)!=None:
        search = BUTTONS.get(key)
    else:
        search = FRESH.get(key)
    if not search:
        await query.answer(script.OLD_ALRT_TXT.format(query.from_user.first_name),show_alert=True)
        return

    files, n_offset, total = await get_search_results(query.message.chat.id, search, offset=offset, filter=True)
    try:
        n_offset = int(n_offset)
    except:
        n_offset = 0

    if not files:
        return
    temp.GETALL[key] = files
    temp.SHORT[query.from_user.id] = query.message.chat.id
    settings = await get_settings(query.message.chat.id)
    pre = 'filep' if settings['file_secure'] else 'file'
    if settings['button']:
        btn = [
            [
                InlineKeyboardButton(
                    text=f"ğŸ“¥[{get_size(file.file_size)}] {' '.join(filter(lambda x: not x.startswith('[') and not x.startswith('@') and not x.startswith('www.'), file.file_name.split()))}", callback_data=f'{pre}#{file.file_id}'
                ),
            ]
            for file in files
        ]

        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"sendfiles#{key}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality#{key}")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{key}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{key}")
        ])
    else:
        btn = []
        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"sendfiles#{key}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality#{key}")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{key}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{key}")
        ])
    try:
        if settings['max_btn']:
            if 0 < offset <= 10:
                off_set = 0
            elif offset == 0:
                off_set = None
            else:
                off_set = offset - 10
            if n_offset == 0:
                btn.append(
                    [InlineKeyboardButton("âŒ« ğğ€ğ‚ğŠ", callback_data=f"next_{req}_{key}_{off_set}"), InlineKeyboardButton(f"{math.ceil(int(offset)/10)+1} / {math.ceil(total/10)}", callback_data="pages")]
                )
            elif off_set is None:
                btn.append([InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(f"{math.ceil(int(offset)/10)+1} / {math.ceil(total/10)}", callback_data="pages"), InlineKeyboardButton("ğğ„ğ—ğ“ âª", callback_data=f"next_{req}_{key}_{n_offset}")])
            else:
                btn.append(
                    [
                        InlineKeyboardButton("âŒ« ğğ€ğ‚ğŠ", callback_data=f"next_{req}_{key}_{off_set}"),
                        InlineKeyboardButton(f"{math.ceil(int(offset)/10)+1} / {math.ceil(total/10)}", callback_data="pages"),
                        InlineKeyboardButton("ğğ„ğ—ğ“ âª", callback_data=f"next_{req}_{key}_{n_offset}")
                    ],
                )
        else:
            if 0 < offset <= int(MAX_B_TN):
                off_set = 0
            elif offset == 0:
                off_set = None
            else:
                off_set = offset - int(MAX_B_TN)
            if n_offset == 0:
                btn.append(
                    [InlineKeyboardButton("âŒ« ğğ€ğ‚ğŠ", callback_data=f"next_{req}_{key}_{off_set}"), InlineKeyboardButton(f"{math.ceil(int(offset)/int(MAX_B_TN))+1} / {math.ceil(total/int(MAX_B_TN))}", callback_data="pages")]
                )
            elif off_set is None:
                btn.append([InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(f"{math.ceil(int(offset)/int(MAX_B_TN))+1} / {math.ceil(total/int(MAX_B_TN))}", callback_data="pages"), InlineKeyboardButton("ğğ„ğ—ğ“ âª", callback_data=f"next_{req}_{key}_{n_offset}")])
            else:
                btn.append(
                    [
                        InlineKeyboardButton("âŒ« ğğ€ğ‚ğŠ", callback_data=f"next_{req}_{key}_{off_set}"),
                        InlineKeyboardButton(f"{math.ceil(int(offset)/int(MAX_B_TN))+1} / {math.ceil(total/int(MAX_B_TN))}", callback_data="pages"),
                        InlineKeyboardButton("ğğ„ğ—ğ“ âª", callback_data=f"next_{req}_{key}_{n_offset}")
                    ],
                )
    except KeyError:
        await save_group_settings(query.message.chat.id, 'max_btn', True)
        if 0 < offset <= 10:
            off_set = 0
        elif offset == 0:
            off_set = None
        else:
            off_set = offset - 10
        if n_offset == 0:
            btn.append(
                [InlineKeyboardButton("âŒ« ğğ€ğ‚ğŠ", callback_data=f"next_{req}_{key}_{off_set}"), InlineKeyboardButton(f"{math.ceil(int(offset)/10)+1} / {math.ceil(total/10)}", callback_data="pages")]
            )
        elif off_set is None:
            btn.append([InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(f"{math.ceil(int(offset)/10)+1} / {math.ceil(total/10)}", callback_data="pages"), InlineKeyboardButton("ğğ„ğ—ğ“ âª", callback_data=f"next_{req}_{key}_{n_offset}")])
        else:
            btn.append(
                [
                    InlineKeyboardButton("âŒ« ğğ€ğ‚ğŠ", callback_data=f"next_{req}_{key}_{off_set}"),
                    InlineKeyboardButton(f"{math.ceil(int(offset)/10)+1} / {math.ceil(total/10)}", callback_data="pages"),
                    InlineKeyboardButton("ğğ„ğ—ğ“ âª", callback_data=f"next_{req}_{key}_{n_offset}")
                ],
            )
    if not settings["button"]:
        cur_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
        time_difference = timedelta(hours=cur_time.hour, minutes=cur_time.minute, seconds=(cur_time.second+(cur_time.microsecond/1000000))) - timedelta(hours=curr_time.hour, minutes=curr_time.minute, seconds=(curr_time.second+(curr_time.microsecond/1000000)))
        remaining_seconds = "{:.2f}".format(time_difference.total_seconds())
        cap = await get_cap(settings, remaining_seconds, files, query, total, search)
        try:
            await query.message.edit_text(text=cap, reply_markup=InlineKeyboardMarkup(btn), disable_web_page_preview=True)
        except MessageNotModified:
            pass
    else:
        try:
            await query.edit_message_reply_markup(
                reply_markup=InlineKeyboardMarkup(btn)
            )
        except MessageNotModified:
            pass
    await query.answer()




@Client.on_message(filters.private & filters.text & filters.incoming)
async def pm_text(bot, message):
    content = message.text
    user = message.from_user.first_name
    user_id = message.from_user.id
    if content.startswith("/") or content.startswith("#"): return  # ignore commands and hashtags
    if user_id in ADMINS: return # ignore admins
    await message.reply_text("<b>Yá´á´œÊ€ á´á´‡ssá´€É¢á´‡ Êœá´€s Ê™á´‡á´‡É´ sá´‡É´á´› á´›á´ á´Ê á´á´á´…á´‡Ê€á´€á´›á´Ê€s !</b>")
    await bot.send_message(
        chat_id=LOG_CHANNEL,
        text=f"<b>#ğğŒ_ğŒğ’ğ†\n\nNá´€á´á´‡ : {user}\n\nID : {user_id}\n\nMá´‡ssá´€É¢á´‡ : {content}</b>"
    )


@Client.on_callback_query(filters.regex(r"^languages#"))
async def languages_cb_handler(client: Client, query: CallbackQuery):

    try:
        if int(query.from_user.id) not in [query.message.reply_to_message.from_user.id, 0]:
            return await query.answer(
                f"âš ï¸ Êœá´‡ÊŸÊŸá´{query.from_user.first_name},\ná´›ÊœÉªêœ± Éªêœ± É´á´á´› Êá´á´œÊ€ á´á´á´ Éªá´‡ Ê€á´‡Qá´œá´‡êœ±á´›,\nÊ€á´‡Qá´œá´‡êœ±á´› Êá´á´œÊ€'êœ±...",
                show_alert=True,
            )
    except:
        pass
    _, key = query.data.split("#")
    # if BUTTONS.get(key+"1")!=None:
    #     search = BUTTONS.get(key+"1")
    # else:
    #     search = BUTTONS.get(key)
    #     BUTTONS[key+"1"] = search
    search = FRESH.get(key)
    search = search.replace(' ', '_')
    btn = []
    for i in range(0, len(LANGUAGES)-1, 2):
        btn.append([
            InlineKeyboardButton(
                text=LANGUAGES[i].title(),
                callback_data=f"fl#{LANGUAGES[i].lower()}#{key}"
            ),
            InlineKeyboardButton(
                text=LANGUAGES[i+1].title(),
                callback_data=f"fl#{LANGUAGES[i+1].lower()}#{key}"
            ),
        ])

    btn.insert(
        0,
        [
            InlineKeyboardButton(
                text="ğŸ‘‡ ğ–²ğ–¾ğ—…ğ–¾ğ–¼ğ— ğ–¸ğ—ˆğ—ğ—‹ ğ–«ğ–ºğ—‡ğ—€ğ—ğ–ºğ—€ğ–¾ğ—Œ ğŸ‘‡", callback_data="ident"
            )
        ],
    )
    req = query.from_user.id
    offset = 0
    btn.append([InlineKeyboardButton(text="â†­ Ê™á´€á´„á´‹ á´›á´ êœ°ÉªÊŸá´‡s â€‹â†­", callback_data=f"fl#homepage#{key}")])

    await query.edit_message_reply_markup(InlineKeyboardMarkup(btn))
    

@Client.on_callback_query(filters.regex(r"^fl#"))
async def filter_languages_cb_handler(client: Client, query: CallbackQuery):
    _, lang, key = query.data.split("#")
    curr_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
    search = FRESH.get(key)
    search = search.replace("_", " ")
    baal = lang in search
    if baal:
        search = search.replace(lang, "")
    else:
        search = search
    req = query.from_user.id
    chat_id = query.message.chat.id
    message = query.message
    try:
        if int(req) not in [query.message.reply_to_message.from_user.id, 0]:
            return await query.answer(
                f"âš ï¸ Êœá´‡ÊŸÊŸá´{query.from_user.first_name},\ná´›ÊœÉªêœ± Éªêœ± É´á´á´› Êá´á´œÊ€ á´á´á´ Éªá´‡ Ê€á´‡Qá´œá´‡êœ±á´›,\nÊ€á´‡Qá´œá´‡êœ±á´› Êá´á´œÊ€'êœ±...",
                show_alert=True,
            )
    except:
        pass
    if lang != "homepage":
        search = f"{search} {lang}" 
    BUTTONS[key] = search

    files, offset, total_results = await get_search_results(chat_id, search, offset=0, filter=True)
    if not files:
        await query.answer("ğŸš« ğ—¡ğ—¼ ğ—™ğ—¶ğ—¹ğ—² ğ—ªğ—²ğ—¿ğ—² ğ—™ğ—¼ğ˜‚ğ—»ğ—± ğŸš«", show_alert=1)
        return
    temp.GETALL[key] = files
    settings = await get_settings(message.chat.id)
    pre = 'filep' if settings['file_secure'] else 'file'
    if settings["button"]:
        btn = [
            [
                InlineKeyboardButton(
                    text=f"[{get_size(file.file_size)}] {' '.join(filter(lambda x: not x.startswith('[') and not x.startswith('@') and not x.startswith('www.'), file.file_name.split()))}", callback_data=f'{pre}#{file.file_id}'
                ),
            ]
            for file in files
        ]
        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"sendfiles#{key}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality#{key}")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{key}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{key}")
        ])
    else:
        btn = []
        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"sendfiles#{key}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality#{key}")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{key}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{key}")
        ])

    if offset != "":
        try:
            if settings['max_btn']:
                btn.append(
                    [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/10)}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
                )
    
            else:
                btn.append(
                    [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/int(MAX_B_TN))}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
                )
        except KeyError:
            await save_group_settings(query.message.chat.id, 'max_btn', True)
            btn.append(
                [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/10)}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
            )
    else:
        btn.append(
            [InlineKeyboardButton(text="ğğ ğŒğğ‘ğ„ ğğ€ğ†ğ„ğ’ ğ€ğ•ğ€ğˆğ‹ğ€ğğ‹ğ„",callback_data="pages")]
        )
    
    if not settings["button"]:
        cur_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
        time_difference = timedelta(hours=cur_time.hour, minutes=cur_time.minute, seconds=(cur_time.second+(cur_time.microsecond/1000000))) - timedelta(hours=curr_time.hour, minutes=curr_time.minute, seconds=(curr_time.second+(curr_time.microsecond/1000000)))
        remaining_seconds = "{:.2f}".format(time_difference.total_seconds())
        cap = await get_cap(settings, remaining_seconds, files, query, total_results, search)
        try:
            await query.message.edit_text(text=cap, reply_markup=InlineKeyboardMarkup(btn), disable_web_page_preview=True)
        except MessageNotModified:
            pass
    else:
        try:
            await query.edit_message_reply_markup(
                reply_markup=InlineKeyboardMarkup(btn)
            )
        except MessageNotModified:
            pass
    await query.answer()
    
    
    
@Client.on_callback_query(filters.regex(r"^seasons#"))
async def seasons_cb_handler(client: Client, query: CallbackQuery):

    try:
        if int(query.from_user.id) not in [query.message.reply_to_message.from_user.id, 0]:
            return await query.answer(
                f"âš ï¸ Êœá´‡ÊŸÊŸá´{query.from_user.first_name},\ná´›ÊœÉªêœ± Éªêœ± É´á´á´› Êá´á´œÊ€ á´á´á´ Éªá´‡ Ê€á´‡Qá´œá´‡êœ±á´›,\nÊ€á´‡Qá´œá´‡êœ±á´› Êá´á´œÊ€'êœ±...",
                show_alert=True,
            )
    except:
        pass
    
    _, key = query.data.split("#")
    # if BUTTONS.get(key+"2")!=None:
    #     search = BUTTONS.get(key+"2")
    # else:
    #     search = BUTTONS.get(key)
    #     BUTTONS[key+"2"] = search
    search = FRESH.get(key)
    BUTTONS[key] = None
    search = search.replace(' ', '_')
    btn = []
    for i in range(0, len(SEASONS)-1, 2):
        btn.append([
            InlineKeyboardButton(
                text=SEASONS[i].title(),
                callback_data=f"fs#{SEASONS[i].lower()}#{key}"
            ),
            InlineKeyboardButton(
                text=SEASONS[i+1].title(),
                callback_data=f"fs#{SEASONS[i+1].lower()}#{key}"
            ),
        ])

    btn.insert(
        0,
        [
            InlineKeyboardButton(
                text="ğŸ‘‡ ğ–²ğ–¾ğ—…ğ–¾ğ–¼ğ— Season ğŸ‘‡", callback_data="ident"
            )
        ],
    )
    req = query.from_user.id
    offset = 0
    btn.append([InlineKeyboardButton(text="â†­ Ê™á´€á´„á´‹ á´›á´ êœ°ÉªÊŸá´‡s â€‹â†­", callback_data=f"next_{req}_{key}_{offset}")])

    await query.edit_message_reply_markup(InlineKeyboardMarkup(btn))


@Client.on_callback_query(filters.regex(r"^fs#"))
async def filter_seasons_cb_handler(client: Client, query: CallbackQuery):
    _, seas, key = query.data.split("#")
    curr_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
    search = FRESH.get(key)
    search = search.replace("_", " ")
    sea = ""
    season_search = ["s01","s02", "s03", "s04", "s05", "s06", "s07", "s08", "s09", "s10", "season 01","season 02","season 03","season 04","season 05","season 06","season 07","season 08","season 09","season 10", "season 1","season 2","season 3","season 4","season 5","season 6","season 7","season 8","season 9"]
    for x in range (len(season_search)):
        if season_search[x] in search:
            sea = season_search[x]
            break
    if sea:
        search = search.replace(sea, "")
    else:
        search = search
    
    req = query.from_user.id
    chat_id = query.message.chat.id
    message = query.message
    try:
        if int(req) not in [query.message.reply_to_message.from_user.id, 0]:
            return await query.answer(
                f"âš ï¸ Êœá´‡ÊŸÊŸá´{query.from_user.first_name},\ná´›ÊœÉªêœ± Éªêœ± É´á´á´› Êá´á´œÊ€ á´á´á´ Éªá´‡ Ê€á´‡Qá´œá´‡êœ±á´›,\nÊ€á´‡Qá´œá´‡êœ±á´› Êá´á´œÊ€'êœ±...",
                show_alert=True,
            )
    except:
        pass
    
    searchagn = search
    search1 = search
    search2 = search
    search = f"{search} {seas}"
    BUTTONS0[key] = search
    
    files, _, _ = await get_search_results(chat_id, search, max_results=10)
    files = [file for file in files if re.search(seas, file.file_name, re.IGNORECASE)]
    
    seas1 = "s01" if seas == "season 1" else "s02" if seas == "season 2" else "s03" if seas == "season 3" else "s04" if seas == "season 4" else "s05" if seas == "season 5" else "s06" if seas == "season 6" else "s07" if seas == "season 7" else "s08" if seas == "season 8" else "s09" if seas == "season 9" else "s10" if seas == "season 10" else ""
    search1 = f"{search1} {seas1}"
    BUTTONS1[key] = search1
    files1, _, _ = await get_search_results(chat_id, search1, max_results=10)
    files1 = [file for file in files1 if re.search(seas1, file.file_name, re.IGNORECASE)]
    
    if files1:
        files.extend(files1)
    
    seas2 = "season 01" if seas == "season 1" else "season 02" if seas == "season 2" else "season 03" if seas == "season 3" else "season 04" if seas == "season 4" else "season 05" if seas == "season 5" else "season 06" if seas == "season 6" else "season 07" if seas == "season 7" else "season 08" if seas == "season 8" else "season 09" if seas == "season 9" else "s010"
    search2 = f"{search2} {seas2}"
    BUTTONS2[key] = search2
    files2, _, _ = await get_search_results(chat_id, search2, max_results=10)
    files2 = [file for file in files2 if re.search(seas2, file.file_name, re.IGNORECASE)]

    if files2:
        files.extend(files2)
        
    if not files:
        await query.answer("ğŸš« ğ—¡ğ—¼ ğ—™ğ—¶ğ—¹ğ—² ğ—ªğ—²ğ—¿ğ—² ğ—™ğ—¼ğ˜‚ğ—»ğ—± ğŸš«", show_alert=1)
        return
    temp.GETALL[key] = files
    settings = await get_settings(message.chat.id)
    pre = 'filep' if settings['file_secure'] else 'file'
    if settings["button"]:
        btn = [
            [
                InlineKeyboardButton(
                    text=f"[{get_size(file.file_size)}] {' '.join(filter(lambda x: not x.startswith('[') and not x.startswith('@') and not x.startswith('www.'), file.file_name.split()))}", callback_data=f'{pre}#{file.file_id}'
                ),
            ]
            for file in files
        ]
        btn.insert(0, [
            InlineKeyboardButton("ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"sendfiles#{key}"),
            InlineKeyboardButton("Sá´‡ÊŸá´‡á´„á´› á´€É¢á´€ÉªÉ´", callback_data=f"seasons#{key}")
        ])
    else:
        btn = []
        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"sendfiles#{key}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality#{key}")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{key}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{key}")
        ])
        
    offset = 0

    btn.append([
            InlineKeyboardButton(
                text="â†­ Ê™á´€á´„á´‹ á´›á´ êœ°ÉªÊŸá´‡s â€‹â†­",
                callback_data=f"next_{req}_{key}_{offset}"
                ),
    ])
    
    if not settings["button"]:
        cur_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
        time_difference = timedelta(hours=cur_time.hour, minutes=cur_time.minute, seconds=(cur_time.second+(cur_time.microsecond/1000000))) - timedelta(hours=curr_time.hour, minutes=curr_time.minute, seconds=(curr_time.second+(curr_time.microsecond/1000000)))
        remaining_seconds = "{:.2f}".format(time_difference.total_seconds())
        total_results = len(files)
        cap = await get_cap(settings, remaining_seconds, files, query, total_results, search)
        try:
            await query.message.edit_text(text=cap, reply_markup=InlineKeyboardMarkup(btn), disable_web_page_preview=True)
        except MessageNotModified:
            pass
    else:
        try:
            await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(btn))
        except MessageNotModified:
            pass
    await query.answer()



@Client.on_callback_query(filters.regex(r"^quality#"))
async def quality_cb_handler(client: Client, query: CallbackQuery):

    try:
        if int(query.from_user.id) not in [query.message.reply_to_message.from_user.id, 0]:
            return await query.answer(
                f"âš ï¸ Êœá´‡ÊŸÊŸá´{query.from_user.first_name},\ná´›ÊœÉªêœ± Éªêœ± É´á´á´› Êá´á´œÊ€ á´á´á´ Éªá´‡ Ê€á´‡Qá´œá´‡êœ±á´›,\nÊ€á´‡Qá´œá´‡êœ±á´› Êá´á´œÊ€'êœ±...",
                show_alert=True,
            )
    except:
        pass
    _, key = query.data.split("#")
    # if BUTTONS.get(key+"1")!=None:
    #     search = BUTTONS.get(key+"1")
    # else:
    #     search = BUTTONS.get(key)
    #     BUTTONS[key+"1"] = search
    search = FRESH.get(key)
    search = search.replace(' ', '_')
    btn = []
    for i in range(0, len(QUALITY)-1, 2):
        btn.append([
            InlineKeyboardButton(
                text=QUALITY[i].title(),
                callback_data=f"fl#{QUALITY[i].lower()}#{key}"
            ),
            InlineKeyboardButton(
                text=QUALITY[i+1].title(),
                callback_data=f"fl#{QUALITY[i+1].lower()}#{key}"
            ),
        ])

    btn.insert(
        0,
        [
            InlineKeyboardButton(
                text="ğŸ‘‡ ğ–²ğ–¾ğ—…ğ–¾ğ–¼ğ— Quality ğŸ‘‡", callback_data="select"
            )
        ],
    )
    req = query.from_user.id
    offset = 0
    btn.append([InlineKeyboardButton(text="â†­ Ê™á´€á´„á´‹ á´›á´ êœ°ÉªÊŸá´‡s â†­", callback_data=f"fl#homepage#{key}")])

    await query.edit_message_reply_markup(InlineKeyboardMarkup(btn))

@Client.on_callback_query(filters.regex(r"^fq#"))
async def filter_quality_cb_handler(client: Client, query: CallbackQuery):
    _, lang, key = query.data.split("#")
    curr_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
    search = FRESH.get(key)
    search = search.replace("_", " ")
    baal = lang in search
    if baal:
        search = search.replace(quali, "")
    else:
        search = search
    req = query.from_user.id
    chat_id = query.message.chat.id
    message = query.message
    try:
        if int(req) not in [query.message.reply_to_message.from_user.id, 0]:
            return await query.answer(
                f"âš ï¸ Êœá´‡ÊŸÊŸá´{query.from_user.first_name},\ná´›ÊœÉªêœ± Éªêœ± É´á´á´› Êá´á´œÊ€ á´á´á´ Éªá´‡ Ê€á´‡Qá´œá´‡êœ±á´›,\nÊ€á´‡Qá´œá´‡êœ±á´› Êá´á´œÊ€'êœ±...",
                show_alert=True,
            )
    except:
        pass
    if quli != "homepage":
        search = f"{search} {quali}" 
    BUTTONS[key] = search

    files, offset, total_results = await get_search_results(chat_id, search, offset=0, filter=True)
    if not files:
        await query.answer("âŒ ğ—¡ğ—¼ ğ—™ğ—¶ğ—¹ğ—² ğ—ªğ—²ğ—¿ğ—² ğ—™ğ—¼ğ˜‚ğ—»ğ—± âŒ", show_alert=1)
        return
    temp.GETALL[key] = files
    settings = await get_settings(message.chat.id)
    pre = 'filep' if settings['file_secure'] else 'file'
    if settings["button"]:
        btn = [
            [
                InlineKeyboardButton(
                    text=f"[{get_size(file.file_size)}] {' '.join(filter(lambda x: not x.startswith('[') and not x.startswith('@') and not x.startswith('Tg_@StreamersHub_') and not x.startswith('Tg_@') and not x.startswith('www.') and not x.startswith('tg') and not x.startswith('telegram'), file.file_name.split()))}", callback_data=f'{pre}#{file.file_id}'
                ),
            ]
            for file in files
        ]
        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"sendfiles#{key}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality#{key}")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{key}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{key}")
        ])
    else:
        btn = []
        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"sendfiles#{key}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality#{key}")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{key}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{key}")
        ])

    if offset != "":
        try:
            if settings['max_btn']:
                btn.append(
                    [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/10)}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
                )
    
            else:
                btn.append(
                    [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/int(MAX_B_TN))}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
                )
        except KeyError:
            await save_group_settings(query.message.chat.id, 'max_btn', True)
            btn.append(
                [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/10)}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
            )
    else:
        btn.append(
            [InlineKeyboardButton(text="ğğ ğŒğğ‘ğ„ ğğ€ğ†ğ„ğ’ ğ€ğ•ğ€ğˆğ‹ğ€ğğ‹ğ„",callback_data="pages")]
        )
    
    if not settings["button"]:
        cur_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
        time_difference = timedelta(hours=cur_time.hour, minutes=cur_time.minute, seconds=(cur_time.second+(cur_time.microsecond/1000000))) - timedelta(hours=curr_time.hour, minutes=curr_time.minute, seconds=(curr_time.second+(curr_time.microsecond/1000000)))
        remaining_seconds = "{:.2f}".format(time_difference.total_seconds())
        cap = await get_cap(settings, remaining_seconds, files, query, total_results, search)
        try:
            await query.message.edit_text(text=cap, reply_markup=InlineKeyboardMarkup(btn), disable_web_page_preview=True)
        except MessageNotModified:
            pass
    else:
        try:
            await query.edit_message_reply_markup(
                reply_markup=InlineKeyboardMarkup(btn)
            )
        except MessageNotModified:
            pass
    await query.answer()


@Client.on_callback_query()
async def cb_handler(client: Client, query: CallbackQuery):
    if query.data == "close_data":
        await query.message.delete()
    elif query.data == "gfiltersdeleteallconfirm":
        await del_allg(query.message, 'gfilters')
        await query.answer("Dá´É´á´‡ !")
        return
    elif query.data == "gfiltersdeleteallcancel": 
        await query.message.reply_to_message.delete()
        await query.message.delete()
        await query.answer("PÊ€á´á´„á´‡ss Cá´€É´á´„á´‡ÊŸÊŸá´‡á´… !")
        return
    elif query.data == "delallconfirm":
        userid = query.from_user.id
        chat_type = query.message.chat.type

        if chat_type == enums.ChatType.PRIVATE:
            grpid = await active_connection(str(userid))
            if grpid is not None:
                grp_id = grpid
                try:
                    chat = await client.get_chat(grpid)
                    title = chat.title
                except:
                    await query.message.edit_text("Má´€á´‹á´‡ sá´œÊ€á´‡ I'á´ á´˜Ê€á´‡sá´‡É´á´› ÉªÉ´ Êá´á´œÊ€ É¢Ê€á´á´œá´˜!!", quote=True)
                    return await query.answer(MSG_ALRT)
            else:
                await query.message.edit_text(
                    "I'á´ É´á´á´› á´„á´É´É´á´‡á´„á´›á´‡á´… á´›á´ á´€É´Ê É¢Ê€á´á´œá´˜s!\nCÊœá´‡á´„á´‹ /connections á´Ê€ á´„á´É´É´á´‡á´„á´› á´›á´ á´€É´Ê É¢Ê€á´á´œá´˜s",
                    quote=True
                )
                return await query.answer(MSG_ALRT)

        elif chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
            grp_id = query.message.chat.id
            title = query.message.chat.title

        else:
            return await query.answer(MSG_ALRT)

        st = await client.get_chat_member(grp_id, userid)
        if (st.status == enums.ChatMemberStatus.OWNER) or (str(userid) in ADMINS):
            await del_all(query.message, grp_id, title)
        else:
            await query.answer("Yá´á´œ É´á´‡á´‡á´… á´›á´ Ê™á´‡ GÊ€á´á´œá´˜ Oá´¡É´á´‡Ê€ á´Ê€ á´€É´ Aá´œá´›Êœ Usá´‡Ê€ á´›á´ á´…á´ á´›Êœá´€á´›!", show_alert=True)
    elif query.data == "delallcancel":
        userid = query.from_user.id
        chat_type = query.message.chat.type

        if chat_type == enums.ChatType.PRIVATE:
            await query.message.reply_to_message.delete()
            await query.message.delete()

        elif chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
            grp_id = query.message.chat.id
            st = await client.get_chat_member(grp_id, userid)
            if (st.status == enums.ChatMemberStatus.OWNER) or (str(userid) in ADMINS):
                await query.message.delete()
                try:
                    await query.message.reply_to_message.delete()
                except:
                    pass
            else:
                await query.answer("TÊœá´€á´›'s É´á´á´› Ò“á´Ê€ Êá´á´œ!!", show_alert=True)
    elif "groupcb" in query.data:
        await query.answer()

        group_id = query.data.split(":")[1]

        act = query.data.split(":")[2]
        hr = await client.get_chat(int(group_id))
        title = hr.title
        user_id = query.from_user.id

        if act == "":
            stat = "CONNECT"
            cb = "connectcb"
        else:
            stat = "DISCONNECT"
            cb = "disconnect"

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(f"{stat}", callback_data=f"{cb}:{group_id}"),
             InlineKeyboardButton("DELETE", callback_data=f"deletecb:{group_id}")],
            [InlineKeyboardButton("BACK", callback_data="backcb")]
        ])

        await query.message.edit_text(
            f"GÊ€á´á´œá´˜ Ná´€á´á´‡ : **{title}**\nGÊ€á´á´œá´˜ ID : `{group_id}`",
            reply_markup=keyboard,
            parse_mode=enums.ParseMode.MARKDOWN
        )
        return await query.answer(MSG_ALRT)
    elif "connectcb" in query.data:
        await query.answer()

        group_id = query.data.split(":")[1]

        hr = await client.get_chat(int(group_id))

        title = hr.title

        user_id = query.from_user.id

        mkact = await make_active(str(user_id), str(group_id))

        if mkact:
            await query.message.edit_text(
                f"Cá´É´É´á´‡á´„á´›á´‡á´… á´›á´ **{title}**",
                parse_mode=enums.ParseMode.MARKDOWN
            )
        else:
            await query.message.edit_text('Sá´á´á´‡ á´‡Ê€Ê€á´Ê€ á´á´„á´„á´œÊ€Ê€á´‡á´…!!', parse_mode=enums.ParseMode.MARKDOWN)
        return await query.answer(MSG_ALRT)
    elif "disconnect" in query.data:
        await query.answer()

        group_id = query.data.split(":")[1]

        hr = await client.get_chat(int(group_id))

        title = hr.title
        user_id = query.from_user.id

        mkinact = await make_inactive(str(user_id))

        if mkinact:
            await query.message.edit_text(
                f"DÉªsá´„á´É´É´á´‡á´„á´›á´‡á´… Ò“Ê€á´á´ **{title}**",
                parse_mode=enums.ParseMode.MARKDOWN
            )
        else:
            await query.message.edit_text(
                f"Sá´á´á´‡ á´‡Ê€Ê€á´Ê€ á´á´„á´„á´œÊ€Ê€á´‡á´…!!",
                parse_mode=enums.ParseMode.MARKDOWN
            )
        return await query.answer(MSG_ALRT)
    elif "deletecb" in query.data:
        await query.answer()

        user_id = query.from_user.id
        group_id = query.data.split(":")[1]

        delcon = await delete_connection(str(user_id), str(group_id))

        if delcon:
            await query.message.edit_text(
                "Sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… á´„á´É´É´á´‡á´„á´›Éªá´É´ !"
            )
        else:
            await query.message.edit_text(
                f"Sá´á´á´‡ á´‡Ê€Ê€á´Ê€ á´á´„á´„á´œÊ€Ê€á´‡á´…!!",
                parse_mode=enums.ParseMode.MARKDOWN
            )
        return await query.answer(MSG_ALRT)
    elif query.data == "backcb":
        await query.answer()

        userid = query.from_user.id

        groupids = await all_connections(str(userid))
        if groupids is None:
            await query.message.edit_text(
                "TÊœá´‡Ê€á´‡ á´€Ê€á´‡ É´á´ á´€á´„á´›Éªá´ á´‡ á´„á´É´É´á´‡á´„á´›Éªá´É´s!! Cá´É´É´á´‡á´„á´› á´›á´ sá´á´á´‡ É¢Ê€á´á´œá´˜s Ò“ÉªÊ€sá´›.",
            )
            return await query.answer(MSG_ALRT)
        buttons = []
        for groupid in groupids:
            try:
                ttl = await client.get_chat(int(groupid))
                title = ttl.title
                active = await if_active(str(userid), str(groupid))
                act = " - ACTIVE" if active else ""
                buttons.append(
                    [
                        InlineKeyboardButton(
                            text=f"{title}{act}", callback_data=f"groupcb:{groupid}:{act}"
                        )
                    ]
                )
            except:
                pass
        if buttons:
            await query.message.edit_text(
                "Yá´á´œÊ€ á´„á´É´É´á´‡á´„á´›á´‡á´… É¢Ê€á´á´œá´˜ á´…á´‡á´›á´€ÉªÊŸs ;\n\n",
                reply_markup=InlineKeyboardMarkup(buttons)
            )
    elif "gfilteralert" in query.data:
        grp_id = query.message.chat.id
        i = query.data.split(":")[1]
        keyword = query.data.split(":")[2]
        reply_text, btn, alerts, fileid = await find_gfilter('gfilters', keyword)
        if alerts is not None:
            alerts = ast.literal_eval(alerts)
            alert = alerts[int(i)]
            alert = alert.replace("\\n", "\n").replace("\\t", "\t")
            await query.answer(alert, show_alert=True)
    elif "alertmessage" in query.data:
        grp_id = query.message.chat.id
        i = query.data.split(":")[1]
        keyword = query.data.split(":")[2]
        reply_text, btn, alerts, fileid = await find_filter(grp_id, keyword)
        if alerts is not None:
            alerts = ast.literal_eval(alerts)
            alert = alerts[int(i)]
            alert = alert.replace("\\n", "\n").replace("\\t", "\t")
            await query.answer(alert, show_alert=True)
    if query.data.startswith("file"):
        
        clicked = query.from_user.id
        try:
            typed = query.message.reply_to_message.from_user.id
        except:
            typed = query.from_user.id
        ident, file_id = query.data.split("#")
        
        files_ = await get_file_details(file_id)
        if not files_:
            return await query.answer('Ná´ sá´œá´„Êœ Ò“ÉªÊŸá´‡ á´‡xÉªsá´›.', show_alert=True)
        files = files_[0]   

#    if query.data.startswith("file"):
#        ident, file_id = query.data.split("#")
#        clicked = query.from_user.id #fetching the ID of the user who clicked the button
#        try:
#            typed = query.message.reply_to_message.from_user.id #fetching user ID of the user who sent the movie request
#        except:
#            typed = clicked #if failed, uses the clicked user's ID as requested user ID
#        files_ = await get_file_details(file_id)
#        if not files_:
#            return await query.answer('No such file exist.')
#        files = files_[0]
        title = files.file_name
        size = get_size(files.file_size)
        f_caption = files.caption
        settings = await get_settings(query.message.chat.id)
        if CUSTOM_FILE_CAPTION:
            try:
                f_caption = CUSTOM_FILE_CAPTION.format(file_name='' if title is None else title,
                                                       file_size='' if size is None else size,
                                                       file_caption='' if f_caption is None else f_caption)
            except Exception as e:
                logger.exception(e)
            f_caption = f_caption
        if f_caption is None:
            f_caption = f"{files.file_name}"

        try:
            if AUTH_CHANNEL and not await is_subscribed(client, query):
                if clicked == typed:
                    await query.answer(url=f"https://t.me/{temp.U_NAME}?start={ident}_{file_id}")
                    return
                else:
                    await query.answer(f"Há´‡Ê {query.from_user.first_name}, TÊœÉªs Is Ná´á´› Yá´á´œÊ€ Má´á´ Éªá´‡ Rá´‡Ç«á´œá´‡sá´›. Rá´‡Ç«á´œá´‡sá´› Yá´á´œÊ€'s !", show_alert=True)
            elif settings['botpm']:
                if clicked == typed:
                    await query.answer(url=f"https://t.me/{temp.U_NAME}?start={ident}_{file_id}")
                    return
                else:
                    await query.answer(f"Há´‡Ê {query.from_user.first_name}, TÊœÉªs Is Ná´á´› Yá´á´œÊ€ Má´á´ Éªá´‡ Rá´‡Ç«á´œá´‡sá´›. Rá´‡Ç«á´œá´‡sá´› Yá´á´œÊ€'s !", show_alert=True)
            else:
                if clicked == typed:
                    content = query.message.reply_to_message.text
                    imdb = await get_poster(content) if IMDB else None
                    present = datetime.now(tz=pytz.timezone("Asia/Kolkata"))
                    time = present.strftime("%I:%M:%S %p")
                    date = present.strftime("%d-%B-%Y")
                    day = present.strftime("%A")
                    file_send=await client.send_cached_media(
                        chat_id=FILE_CHANNEL,
                        file_id=file_id,
                        caption=script.CHANNEL_CAP.format(query.from_user.mention, title, query.message.chat.title),
                        protect_content=True if ident == "filep" else False,
                        reply_markup=InlineKeyboardMarkup(
                             [
                                [
                                     InlineKeyboardButton(f"ğŸ“©ğ’ğšğ¯ğ ğ…ğ¢ğ¥ğ ğˆğğŸ“©", url=f"https://t.me/share/url?url={file_id}")
                                 ],
                                 [
                                 InlineKeyboardButton(f"ğƒğ¨ğ°ğ§ğ¥ğ¨ğšğğŸ’»", url=f"https://t.me/batchfiles_store")
                                 
                                 ]                            
                             ]
                         )
                     )
                
                    Joel_tgx = await query.message.reply_photo(
                        photo=imdb.get('poster'),
                        caption=script.FILE_MSG.format(query.from_user.mention, title, size),
                        parse_mode=enums.ParseMode.HTML,
                        reply_markup=InlineKeyboardMarkup(
                            [
                             [
                              InlineKeyboardButton('ğŸ“¥ ğƒğ¨ğ°ğ§ğ¥ğ¨ğšğ ğ‹ğ¢ğ§ğ¤ ğŸ“¥ ', url = file_send.link)
                           ],[
                              InlineKeyboardButton("âš ï¸ ğ‚ğšğ§'ğ­ ğ€ğœğœğğ¬ğ¬ â“ ğ‚ğ¥ğ¢ğœğ¤ ğ‡ğğ«ğ âš ï¸", url=(FILE_FORWARD))
                             ]
                            ]
                        )
                    )
                
                    await asyncio.sleep(10)
                    await Joel_tgx.delete()
                    await file_send.delete()
                    

                    s = await client.send_message(
                        chat_id=FILE_CHANNEL,                        
                        text=script.DONE_MSG.format(query.from_user.mention, title, size, time, date),
                        parse_mode=enums.ParseMode.HTML,
                        reply_markup=InlineKeyboardMarkup(
                            [
                                [
                                     InlineKeyboardButton(f"ğŸ“©ğ’ğšğ¯ğ ğ…ğ¢ğ¥ğ ğˆğğŸ“©", url=f"https://t.me/share/url?url={file_id}")
                                 ],
                                 [
                                 InlineKeyboardButton(f"ğŸ’»ğ’ğğ§ğ ğ…ğ¢ğ¥ğ ğˆğƒğŸ’»", url=(BATCH_LINK))
                                 
                                 ]                            
                            ]
                        )
                    )
#                    return 
                    name_format = f"okda"
                    image = await Joel_tgx.download(file_name=f"{name_format}.jpg")
                    
                    im = Image.open(image).convert("RGB")
                    im.save(f"{name_format}.webp", "webp")
                    sticker = f"{name_format}.webp"
                    buttons = [[
                     #   InlineKeyboardButton(f"ğŸ“¥{imdb.get('title')} {imdb.get('year')}ğŸ“¥", url=f"https://telegram.me/{temp.U_NAME}?start={ident}_{file_id}")
                        InlineKeyboardButton(f"ğŸ“¥ ğƒğ¨ğ°ğ§ğ¥ğ¨ğšğğğ ğŸ“¥", url= s.link)
                    
                    ], [
                        InlineKeyboardButton(f"âš ï¸ğƒğğ¥ğğ­ğ ğğ¨ğ°âš ï¸", callback_data="dl")
                
                    ]]
                    reply_markup = InlineKeyboardMarkup(buttons)
           
                    sp = await client.send_sticker(
                    chat_id=FILE_CHANNEL,
                    sticker=sticker,            
                    reply_markup=reply_markup,                       
                    )
                    try:
                        await sp.react(choice(Telegram.EMOJIS))
                    except (
                        MessageIdInvalid,
                        EmoticonInvalid,
                        ChatAdminRequired,
                        ReactionInvalid
                    ):
                        pass        
                        os.remove(sticker)
                        os.remove(image)
            
                        return await query.answer('CÊœá´‡á´„á´‹ PM, I Êœá´€á´ á´‡ sá´‡É´á´› Ò“ÉªÊŸá´‡s ÉªÉ´ PM', show_alert=True)
                else:
                    return await query.answer(f"Há´‡Ê {query.from_user.first_name}, TÊœÉªs Is Ná´á´› Yá´á´œÊ€ Má´á´ Éªá´‡ Rá´‡Ç«á´œá´‡sá´›. Rá´‡Ç«á´œá´‡sá´› Yá´á´œÊ€'s !", show_alert=True)
        except UserIsBlocked:
            await query.answer('UÉ´Ê™ÊŸá´á´„á´‹ á´›Êœá´‡ Ê™á´á´› á´á´€ÊœÉ´ !', show_alert=True)
        except PeerIdInvalid:
            await query.answer(url=f"https://t.me/{temp.U_NAME}?start={ident}_{file_id}")
        except Exception as e:
            await query.answer(url=f"https://t.me/{temp.U_NAME}?start={ident}_{file_id}")
    elif query.data.startswith("checksub"):
        if AUTH_CHANNEL and not await is_subscribed(client, query):
            await query.answer("Já´ÉªÉ´ á´á´œÊ€ Bá´€á´„á´‹-á´œá´˜ á´„Êœá´€É´É´á´‡ÊŸ á´á´€ÊœÉ´! ğŸ˜’", show_alert=True)
            return
        ident, file_id = query.data.split("#")
        if file_id == "send_all":
            send_files = temp.SEND_ALL_TEMP.get(query.from_user.id)
            is_over = await send_all(client, query.from_user.id, send_files, ident)
            if is_over == 'done':
                return await query.answer(f"Há´‡Ê {query.from_user.first_name}, AÊŸÊŸ Ò“ÉªÊŸá´‡s á´É´ á´›ÊœÉªs á´˜á´€É¢á´‡ Êœá´€s Ê™á´‡á´‡É´ sá´‡É´á´› sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´›á´ Êá´á´œÊ€ PM !", show_alert=True)
            elif is_over == 'fsub':
                return await query.answer("Há´‡Ê, Yá´á´œ á´€Ê€á´‡ É´á´á´› á´Šá´ÉªÉ´á´‡á´… ÉªÉ´ á´Ê Ê™á´€á´„á´‹ á´œá´˜ á´„Êœá´€É´É´á´‡ÊŸ. CÊœá´‡á´„á´‹ á´Ê PM á´›á´ á´Šá´ÉªÉ´ á´€É´á´… É¢á´‡á´› Ò“ÉªÊŸá´‡s !", show_alert=True)
            elif is_over == 'verify':
                return await query.answer("Há´‡Ê, Yá´á´œ Êœá´€á´ á´‡ É´á´á´› á´ á´‡Ê€ÉªÒ“Éªá´‡á´… á´›á´á´…á´€Ê. Yá´á´œ Êœá´€á´ á´‡ á´›á´ á´ á´‡Ê€ÉªÒ“Ê á´›á´ á´„á´É´á´›ÉªÉ´á´œá´‡. CÊœá´‡á´„á´‹ á´Ê PM á´›á´ á´ á´‡Ê€ÉªÒ“Ê á´€É´á´… É¢á´‡á´› Ò“ÉªÊŸá´‡s !", show_alert=True)
            else:
                return await query.answer(f"EÊ€Ê€á´Ê€: {is_over}", show_alert=True)
        files_ = await get_file_details(file_id)
        if not files_:
            return await query.answer('Ná´ sá´œá´„Êœ Ò“ÉªÊŸá´‡ á´‡xÉªsá´›.')
        files = files_[0]
        title = files.file_name
        size = get_size(files.file_size)
        f_caption = files.caption
        if CUSTOM_FILE_CAPTION:
            try:
                f_caption = CUSTOM_FILE_CAPTION.format(file_name='' if title is None else title,
                                                       file_size='' if size is None else size,
                                                       file_caption='' if f_caption is None else f_caption)
            except Exception as e:
                logger.exception(e)
                f_caption = f_caption
        if f_caption is None:
            f_caption = f"{title}"
        await query.answer()
        if IS_VERIFY and not await check_verification(client, query.from_user.id):
            btn = [[
                InlineKeyboardButton("Vá´‡Ê€ÉªÒ“Ê", url=await get_token(client, query.from_user.id, f"https://telegram.me/{temp.U_NAME}?start=", file_id)),
                InlineKeyboardButton("Há´á´¡ Tá´ Vá´‡Ê€ÉªÒ“Ê", url=HOW_TO_VERIFY)
            ]]
            await client.send_message(
                chat_id=query.from_user.id,
                text="<b>Yá´á´œ á´€Ê€á´‡ É´á´á´› á´ á´‡Ê€ÉªÒ“Éªá´‡á´…!\nKÉªÉ´á´…ÊŸÊ á´ á´‡Ê€ÉªÒ“Ê á´›á´ á´„á´É´á´›ÉªÉ´á´œá´‡ Sá´ á´›Êœá´€á´› Êá´á´œ á´„á´€É´ É¢á´‡á´› á´€á´„á´„á´‡ss á´›á´ á´œÉ´ÊŸÉªá´Éªá´›á´‡á´… á´á´á´ Éªá´‡s á´œÉ´á´›ÉªÊŸ 12 Êœá´á´œÊ€s Ò“Ê€á´á´ É´á´á´¡ !</b>",
                protect_content=True if ident == 'checksubp' else False,
                disable_web_page_preview=True,
                parse_mode=enums.ParseMode.HTML,
                reply_markup=InlineKeyboardMarkup(btn)
            )
            return
        await client.send_cached_media(
            chat_id=query.from_user.id,
            file_id=file_id,
            caption=f_caption,
            protect_content=True if ident == 'checksubp' else False,
            reply_markup=InlineKeyboardMarkup(
                [
                 [
                  InlineKeyboardButton('Sá´œá´˜á´˜á´Ê€á´› GÊ€á´á´œá´˜', url=GRP_LNK),
                  InlineKeyboardButton('Uá´˜á´…á´€á´›á´‡s CÊœá´€É´É´á´‡ÊŸ', url=CHNL_LNK)
               ],[
                  InlineKeyboardButton("Bá´á´› Oá´¡É´á´‡Ê€", url="t.me/creatorbeatz")
                 ]
                ]
            )
        )
    elif query.data == "pages":
        await query.answer()

    elif query.data.startswith("send_fall"):
        temp_var, ident, offset, userid = query.data.split("#")
        if int(userid) not in [query.from_user.id, 0]:
            return await query.answer(script.ALRT_TXT.format(query.from_user.first_name), show_alert=True)
        files = temp.SEND_ALL_TEMP.get(query.from_user.id)
        is_over = await send_all(client, query.from_user.id, files, ident)
        if is_over == 'done':
            return await query.answer(f"Há´‡Ê {query.from_user.first_name}, AÊŸÊŸ Ò“ÉªÊŸá´‡s á´É´ á´›ÊœÉªs á´˜á´€É¢á´‡ Êœá´€s Ê™á´‡á´‡É´ sá´‡É´á´› sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´›á´ Êá´á´œÊ€ PM !", show_alert=True)
        elif is_over == 'fsub':
            return await query.answer("Há´‡Ê, Yá´á´œ á´€Ê€á´‡ É´á´á´› á´Šá´ÉªÉ´á´‡á´… ÉªÉ´ á´Ê Ê™á´€á´„á´‹ á´œá´˜ á´„Êœá´€É´É´á´‡ÊŸ. CÊœá´‡á´„á´‹ á´Ê PM á´›á´ á´Šá´ÉªÉ´ á´€É´á´… É¢á´‡á´› Ò“ÉªÊŸá´‡s !", show_alert=True)
        elif is_over == 'verify':
            return await query.answer("Há´‡Ê, Yá´á´œ Êœá´€á´ á´‡ É´á´á´› á´ á´‡Ê€ÉªÒ“Éªá´‡á´… á´›á´á´…á´€Ê. Yá´á´œ Êœá´€á´ á´‡ á´›á´ á´ á´‡Ê€ÉªÒ“Ê á´›á´ á´„á´É´á´›ÉªÉ´á´œá´‡. CÊœá´‡á´„á´‹ á´Ê PM á´›á´ á´ á´‡Ê€ÉªÒ“Ê á´€É´á´… É¢á´‡á´› Ò“ÉªÊŸá´‡s !", show_alert=True)
        else:
            return await query.answer(f"EÊ€Ê€á´Ê€: {is_over}", show_alert=True)

    elif query.data.startswith("killfilesdq"):
        ident, keyword = query.data.split("#")
        await query.message.edit_text(f"<b>Fá´‡á´›á´„ÊœÉªÉ´É¢ FÉªÊŸá´‡s Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword} á´É´ DB... PÊŸá´‡á´€sá´‡ á´¡á´€Éªá´›...</b>")
        files, total = await get_bad_files(keyword)
        await query.message.edit_text(f"<b>Fá´á´œÉ´á´… {total} FÉªÊŸá´‡s Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword} !\n\nFÉªÊŸá´‡ á´…á´‡ÊŸá´‡á´›Éªá´É´ á´˜Ê€á´á´„á´‡ss á´¡ÉªÊŸÊŸ sá´›á´€Ê€á´› ÉªÉ´ 5 sá´‡á´„á´É´á´…s!</b>")
        await asyncio.sleep(5)
        deleted = 0
        async with lock:
            try:
                for file in files:
                    file_ids = file.file_id
                    file_name = file.file_name
                    result = await Media.collection.delete_one({
                        '_id': file_ids,
                    })
                    if not result.deleted_count:
                        result = await Media2.collection.delete_one({
                            '_id': file_ids,
                        })
                    if result.deleted_count:
                        logger.info(f'FÉªÊŸá´‡ Fá´á´œÉ´á´… Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword}! Sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… {file_name} Ò“Ê€á´á´ á´…á´€á´›á´€Ê™á´€sá´‡.')
                        deleted += 1
                        if deleted % 20 == 0:
                            await query.message.edit_text(f"<b>PÊ€á´á´„á´‡ss sá´›á´€Ê€á´›á´‡á´… Ò“á´Ê€ á´…á´‡ÊŸá´‡á´›ÉªÉ´É¢ Ò“ÉªÊŸá´‡s Ò“Ê€á´á´ DB. Sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… {str(deleted)} Ò“ÉªÊŸá´‡s Ò“Ê€á´á´ DB Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword} !\n\nPÊŸá´‡á´€sá´‡ á´¡á´€Éªá´›...</b>")
            except Exception as e:
                logger.exception(e)
                await query.message.edit_text(f'EÊ€Ê€á´Ê€: {e}')
            else:
                await query.message.edit_text(f"<b>PÊ€á´á´„á´‡ss Cá´á´á´˜ÊŸá´‡á´›á´‡á´… Ò“á´Ê€ Ò“ÉªÊŸá´‡ á´…á´‡ÊŸá´‡á´›Éªá´É´ !\n\nSá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… {str(deleted)} Ò“ÉªÊŸá´‡s Ò“Ê€á´á´ DB Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword}.</b>")

    elif query.data.startswith("opnsetgrp"):
        ident, grp_id = query.data.split("#")
        userid = query.from_user.id if query.from_user else None
        st = await client.get_chat_member(grp_id, userid)
        if (
                st.status != enums.ChatMemberStatus.ADMINISTRATOR
                and st.status != enums.ChatMemberStatus.OWNER
                and str(userid) not in ADMINS
        ):
            await query.answer("Yá´á´œ Dá´É´'á´› Há´€á´ á´‡ TÊœá´‡ RÉªÉ¢Êœá´›s Tá´ Dá´ TÊœÉªs !", show_alert=True)
            return
        title = query.message.chat.title
        settings = await get_settings(grp_id)
        if settings is not None:
            buttons = [
                [
                    InlineKeyboardButton('FÉªÊŸá´›á´‡Ê€ Bá´œá´›á´›á´É´',
                                         callback_data=f'setgs#button#{settings["button"]}#{str(grp_id)}'),
                    InlineKeyboardButton('SÉªÉ´É¢ÊŸá´‡' if settings["button"] else 'Dá´á´œÊ™ÊŸá´‡',
                                         callback_data=f'setgs#button#{settings["button"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('FÉªÊŸá´‡ Sá´‡É´á´… Má´á´…á´‡', callback_data=f'setgs#botpm#{settings["botpm"]}#{str(grp_id)}'),
                    InlineKeyboardButton('Má´€É´á´œá´€ÊŸ Sá´›á´€Ê€á´›' if settings["botpm"] else 'Aá´œá´›á´ Sá´‡É´á´…',
                                         callback_data=f'setgs#botpm#{settings["botpm"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('PÊ€á´á´›á´‡á´„á´› Cá´É´á´›á´‡É´á´›',
                                         callback_data=f'setgs#file_secure#{settings["file_secure"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["file_secure"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#file_secure#{settings["file_secure"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Iá´á´…Ê™', callback_data=f'setgs#imdb#{settings["imdb"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["imdb"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#imdb#{settings["imdb"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Sá´˜á´‡ÊŸÊŸ CÊœá´‡á´„á´‹',
                                         callback_data=f'setgs#spell_check#{settings["spell_check"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["spell_check"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#spell_check#{settings["spell_check"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Wá´‡ÊŸá´„á´á´á´‡ MsÉ¢', callback_data=f'setgs#welcome#{settings["welcome"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["welcome"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#welcome#{settings["welcome"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Aá´œá´›á´-Dá´‡ÊŸá´‡á´›á´‡',
                                         callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{str(grp_id)}'),
                    InlineKeyboardButton('10 MÉªÉ´s' if settings["auto_delete"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Aá´œá´›á´-FÉªÊŸá´›á´‡Ê€',
                                         callback_data=f'setgs#auto_ffilter#{settings["auto_ffilter"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["auto_ffilter"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#auto_ffilter#{settings["auto_ffilter"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Má´€x Bá´œá´›á´›á´É´s',
                                         callback_data=f'setgs#max_btn#{settings["max_btn"]}#{str(grp_id)}'),
                    InlineKeyboardButton('10' if settings["max_btn"] else f'{MAX_B_TN}',
                                         callback_data=f'setgs#max_btn#{settings["max_btn"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('SÊœá´Ê€á´›LÉªÉ´á´‹',
                                         callback_data=f'setgs#is_shortlink#{settings["is_shortlink"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["is_shortlink"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#is_shortlink#{settings["is_shortlink"]}#{str(grp_id)}')
                ]
            ]
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.message.edit_text(
                text=f"<b>CÊœá´€É´É¢á´‡ Yá´á´œÊ€ Sá´‡á´›á´›ÉªÉ´É¢s Fá´Ê€ {title} As Yá´á´œÊ€ WÉªsÊœ âš™</b>",
                disable_web_page_preview=True,
                parse_mode=enums.ParseMode.HTML
            )
            await query.message.edit_reply_markup(reply_markup)
        
    elif query.data.startswith("opnsetpm"):
        ident, grp_id = query.data.split("#")
        userid = query.from_user.id if query.from_user else None
        st = await client.get_chat_member(grp_id, userid)
        if (
                st.status != enums.ChatMemberStatus.ADMINISTRATOR
                and st.status != enums.ChatMemberStatus.OWNER
                and str(userid) not in ADMINS
        ):
            await query.answer("Yá´á´œ Dá´É´'á´› Há´€á´ á´‡ TÊœá´‡ RÉªÉ¢Êœá´›s Tá´ Dá´ TÊœÉªs !", show_alert=True)
            return
        title = query.message.chat.title
        settings = await get_settings(grp_id)
        btn2 = [[
                 InlineKeyboardButton("CÊœá´‡á´„á´‹ PM", url=f"t.me/{temp.U_NAME}")
               ]]
        reply_markup = InlineKeyboardMarkup(btn2)
        await query.message.edit_text(f"<b>Yá´á´œÊ€ sá´‡á´›á´›ÉªÉ´É¢s á´á´‡É´á´œ Ò“á´Ê€ {title} Êœá´€s Ê™á´‡á´‡É´ sá´‡É´á´› á´›á´ Êá´á´œÊ€ PM</b>")
        await query.message.edit_reply_markup(reply_markup)
        if settings is not None:
            buttons = [
                [
                    InlineKeyboardButton('FÉªÊŸá´›á´‡Ê€ Bá´œá´›á´›á´É´',
                                         callback_data=f'setgs#button#{settings["button"]}#{str(grp_id)}'),
                    InlineKeyboardButton('SÉªÉ´É¢ÊŸá´‡' if settings["button"] else 'Dá´á´œÊ™ÊŸá´‡',
                                         callback_data=f'setgs#button#{settings["button"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('FÉªÊŸá´‡ Sá´‡É´á´… Má´á´…á´‡', callback_data=f'setgs#botpm#{settings["botpm"]}#{str(grp_id)}'),
                    InlineKeyboardButton('Má´€É´á´œá´€ÊŸ Sá´›á´€Ê€á´›' if settings["botpm"] else 'Aá´œá´›á´ Sá´‡É´á´…',
                                         callback_data=f'setgs#botpm#{settings["botpm"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('PÊ€á´á´›á´‡á´„á´› Cá´É´á´›á´‡É´á´›',
                                         callback_data=f'setgs#file_secure#{settings["file_secure"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["file_secure"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#file_secure#{settings["file_secure"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Iá´á´…Ê™', callback_data=f'setgs#imdb#{settings["imdb"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["imdb"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#imdb#{settings["imdb"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Sá´˜á´‡ÊŸÊŸ CÊœá´‡á´„á´‹',
                                         callback_data=f'setgs#spell_check#{settings["spell_check"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["spell_check"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#spell_check#{settings["spell_check"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Wá´‡ÊŸá´„á´á´á´‡ MsÉ¢', callback_data=f'setgs#welcome#{settings["welcome"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["welcome"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#welcome#{settings["welcome"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Aá´œá´›á´-Dá´‡ÊŸá´‡á´›á´‡',
                                         callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{str(grp_id)}'),
                    InlineKeyboardButton('10 MÉªÉ´s' if settings["auto_delete"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Aá´œá´›á´-FÉªÊŸá´›á´‡Ê€',
                                         callback_data=f'setgs#auto_ffilter#{settings["auto_ffilter"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["auto_ffilter"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#auto_ffilter#{settings["auto_ffilter"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Má´€x Bá´œá´›á´›á´É´s',
                                         callback_data=f'setgs#max_btn#{settings["max_btn"]}#{str(grp_id)}'),
                    InlineKeyboardButton('10' if settings["max_btn"] else f'{MAX_B_TN}',
                                         callback_data=f'setgs#max_btn#{settings["max_btn"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('SÊœá´Ê€á´›LÉªÉ´á´‹',
                                         callback_data=f'setgs#is_shortlink#{settings["is_shortlink"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["is_shortlink"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#is_shortlink#{settings["is_shortlink"]}#{str(grp_id)}')
                ]
            ]
            reply_markup = InlineKeyboardMarkup(buttons)
            await client.send_message(
                chat_id=userid,
                text=f"<b>CÊœá´€É´É¢á´‡ Yá´á´œÊ€ Sá´‡á´›á´›ÉªÉ´É¢s Fá´Ê€ {title} As Yá´á´œÊ€ WÉªsÊœ âš™</b>",
                reply_markup=reply_markup,
                disable_web_page_preview=True,
                parse_mode=enums.ParseMode.HTML,
                reply_to_message_id=query.message.id
            )

    elif query.data.startswith("sett_"):
        data = data.replace("sett_", "")
        data = int(data)
        if query.from_user.id in ADMINS:
            
            await query.message.edit_reply_markup(
                InlineKeyboardMarkup(
                    [
                        [InlineKeyboardButton("ğŸ”ƒ RESTART ğŸ”ƒ",
                            callback_data=f"restart_{data}")],
                        [InlineKeyboardButton("ğŸ“œ LOGS ğŸ“œ",
                            callback_data=f"logs_{data}")],
                        [InlineKeyboardButton("âŒ CLOSE MENU âŒ",
                            callback_data="close")]
                    ]
                )
            )
        else:
            await query.answer("Yá´á´œ á´…á´É´'á´› Êœá´€á´ á´‡ sá´œÒ“Ò“Éªá´„Éªá´€É´á´› Ê€ÉªÉ¢á´›s á´›á´ á´…á´ á´›ÊœÉªs !", show_alert=True)


    elif query.data.startswith("restart_"):
        data = data.replace("restart_", "")
        data = int(data)
        if query.from_user.id in ADMINS:
            
            happ = h_conn[data].apps()[app[data]]
            happ.change_connection(h_conn[data])
            happ.restart()
            await query.answer(f"Restarting - {app[data]}", show_alert=True)

        else:
            await query.answer("Yá´á´œ á´…á´É´'á´› Êœá´€á´ á´‡ sá´œÒ“Ò“Éªá´„Éªá´€É´á´› Ê€ÉªÉ¢á´›s á´›á´ á´…á´ á´›ÊœÉªs !", show_alert=True)


    elif query.data.startswith("logs_"):
        data = data.replace("logs_", "")
        data = int(data)
        if query.from_user.id in ADMINS:
            happ = h_conn[data].apps()[app[data]]
            happ.change_connection(h_conn[data])
            log = happ.get_log()
            file = BytesIO(bytes(log, "utf-8"))
            file.name = f"{app[data]}_log.txt"
            await query.message.reply_document(file)
            await query.answer(f"Error: {e}", show_alert=True)
        else:
            await query.answer("Yá´á´œ á´…á´É´'á´› Êœá´€á´ á´‡ sá´œÒ“Ò“Éªá´„Éªá´€É´á´› Ê€ÉªÉ¢á´›s á´›á´ á´…á´ á´›ÊœÉªs !", show_alert=True)


    elif query.data == "tinfo":
        await query.answer("â–£ á´›Éªá´˜s â–£\n\nâ˜… á´›Êá´˜á´‡ á´„á´Ê€Ê€á´‡á´„á´› sá´˜á´‡ÊŸÊŸÉªÉ´É¢ (É¢á´á´É¢ÊŸá´‡)\n\nâ˜… ÉªÒ“ Êá´á´œ É´á´á´› É¢á´‡á´› Êá´á´œÊ€ Ò“ÉªÊŸá´‡ ÉªÉ´ á´›Êœá´‡ Ê™á´œá´›á´›á´É´ á´›Êœá´‡É´ á´›Êœá´‡ É´á´‡xá´› sá´›á´‡á´˜ Éªs á´„ÊŸÉªá´„á´‹ É´á´‡xá´› Ê™á´œá´›á´›á´É´.\n\nâ˜… á´„á´É´á´›ÉªÉ´á´œá´‡ á´›ÊœÉªs á´á´‡á´›Êœá´á´… á´›á´ É¢á´‡á´›á´›ÉªÉ´É¢ Êá´á´œ Ò“ÉªÊŸá´‡\n\nâ£ á´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê á´„ÉªÉ´á´‡á´á´€ÊŸá´€. á´„á´á´", show_alert=True)

    elif query.data == "feng":
        await query.answer("Dá´œá´‡ á´›á´ á´„á´á´˜ÊÊ€ÉªÉ¢Êœá´› á´›Êœá´‡ Ò“ÉªÊŸá´‡ á´¡ÉªÊŸÊŸ Ê™á´‡ á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ Êœá´‡Ê€á´‡ ÉªÉ´ 3 á´ÉªÉ´á´œá´›á´‡s sá´ á´…á´á´¡É´ÊŸá´á´€á´… á´€Ò“á´›á´‡Ê€ á´á´á´ ÉªÉ´É¢ Ò“Ê€á´á´ Êœá´‡Ê€á´‡ á´›á´ sá´á´á´‡á´¡Êœá´‡Ê€á´‡ á´‡ÊŸsá´‡!", show_alert=True)

    elif query.data == "fmal":
        await query.answer("à´•àµ‹à´ªàµà´ªà´¿à´±àµˆà´±àµà´±àµ à´‰à´³àµà´³à´¤àµà´•àµŠà´£àµà´Ÿàµ à´«à´¯àµ½ 3 à´®à´¿à´¨à´¿à´±àµà´±à´¿à´¨àµà´³àµà´³à´¿àµ½ à´‡à´µà´¿à´Ÿàµ†à´¨à´¿à´¨àµà´¨àµà´‚ à´¡à´¿à´²àµ€à´±àµà´±àµ à´†à´•àµà´¨àµà´¨à´¤à´¾à´£àµ à´…à´¤àµà´•àµŠà´£àµà´Ÿàµ à´‡à´µà´¿à´Ÿàµ† à´¨à´¿à´¨àµà´¨àµà´‚ à´®à´±àµà´±àµ†à´µà´¿à´Ÿàµ†à´•àµà´•àµ†à´™àµà´•à´¿à´²àµà´‚ à´®à´¾à´±àµà´±à´¿à´¯à´¤à´¿à´¨àµ à´¶àµ‡à´·à´‚ à´¡àµ—àµºà´²àµ‹à´¡àµ à´šàµ†à´¯àµà´¯àµà´•!", show_alert=True)
        
    elif query.data == "ftam":
        await query.answer("à®ªà®¤à®¿à®ªà¯à®ªà¯à®°à®¿à®®à¯ˆ à®•à®¾à®°à®£à®®à®¾à®•, à®•à¯‹à®ªà¯à®ªà¯ à®‡à®™à¯à®•à®¿à®°à¯à®¨à¯à®¤à¯ 3 à®¨à®¿à®®à®¿à®Ÿà®™à¯à®•à®³à®¿à®²à¯ à®¨à¯€à®•à¯à®•à®ªà¯à®ªà®Ÿà¯à®®à¯, à®à®©à®µà¯‡ à®‡à®™à¯à®•à®¿à®°à¯à®¨à¯à®¤à¯ à®µà¯‡à®±à¯ à®à®™à¯à®•à®¾à®µà®¤à¯ à®¨à®•à®°à¯à®¤à¯à®¤à®ªà¯à®ªà®Ÿà¯à®Ÿ à®ªà®¿à®±à®•à¯ à®ªà®¤à®¿à®µà®¿à®±à®•à¯à®•à®µà¯à®®à¯!", show_alert=True)

    elif query.data == "fhin":
        await query.answer("à¤•à¥‰à¤ªà¥€à¤°à¤¾à¤‡à¤Ÿ à¤•à¥‡ à¤•à¤¾à¤°à¤£ à¤«à¤¼à¤¾à¤‡à¤² à¤¯à¤¹à¤¾à¤‚ à¤¸à¥‡ 3 à¤®à¤¿à¤¨à¤Ÿ à¤®à¥‡à¤‚ à¤¡à¤¿à¤²à¥€à¤Ÿ à¤¹à¥‹ à¤œà¤¾à¤à¤—à¥€ à¤‡à¤¸à¤²à¤¿à¤ à¤¯à¤¹à¤¾à¤‚ à¤¸à¥‡ à¤•à¤¹à¥€à¤‚ à¤”à¤° à¤²à¥‡ à¤œà¤¾à¤•à¤° à¤¡à¤¾à¤‰à¤¨à¤²à¥‹à¤¡ à¤•à¤°à¥‡à¤‚!", show_alert=True)
           

    elif query.data == "fileinfo":
        await query.answer("Dá´œá´‡ á´›á´ á´„á´á´˜ÊÊ€ÉªÉ¢Êœá´› á´›Êœá´‡ Ò“ÉªÊŸá´‡ á´¡ÉªÊŸÊŸ Ê™á´‡ á´…á´‡ÊŸá´‡á´›á´‡á´… Ò“Ê€á´á´ Êœá´‡Ê€á´‡ ÉªÉ´ 3 á´ÉªÉ´á´œá´›á´‡s sá´ á´…á´á´¡É´ÊŸá´á´€á´… á´€Ò“á´›á´‡Ê€ á´á´á´ ÉªÉ´É¢ Ò“Ê€á´á´ Êœá´‡Ê€á´‡ á´›á´ sá´á´á´‡á´¡Êœá´‡Ê€á´‡ á´‡ÊŸsá´‡!", show_alert=True)


   
    


    elif query.data == "fileinfos":
        offset = 0
        search = query.message.reply_to_message.text
        files, n_offset, total = await get_search_results(query.message.chat.id, search, offset=offset, filter=True)
        try:
            n_offset = int(n_offset)
        except:
            n_offset = 0
        await query.answer(f"ğŸ’¡ğ‡ğğ¥ğ¥ğ¨: {query.from_user.first_name}\nğŸ¬ğŒğ¨ğ¯ğ¢ğ ğğšğ¦ğ: {search}\nğŸ“ ğ…ğ¢ğ¥ğğ¬: {total}\nğŸ’ à´¤à´¾à´´àµ† à´•à´¾à´£àµà´¨àµà´¨ à´¬à´Ÿàµà´Ÿà´£à´¿àµ½ à´•àµà´²à´¿à´•àµà´•àµ à´šàµ†à´¯àµà´¤à´¾àµ½ à´«à´¯àµ½ à´•à´¿à´Ÿàµà´Ÿàµà´‚.\nğŸˆğ¶ğ‘–ğ‘™ğ‘ğ‘˜ ğ‘‚ğ‘› ğ‘‡â„ğ‘’ ğµğ‘¢ğ‘¡ğ‘¡ğ‘œğ‘› ğµğ‘’ğ‘™ğ‘œğ‘¤ ğ‘‡ğ‘œ ğºğ‘’ğ‘¡ ğ‘‡â„ğ‘’ ğ¹ğ‘–ğ‘™ğ‘’.", show_alert=True)

    elif query.data == "reqinfo":
        await query.answer(text=script.REQINFO, show_alert=True)

    elif query.data == "select":
        query_id = query.message.chat.id
        content = query.message.reply_to_message.text
        imdb = await get_poster(content) if IMDB else None
        await query.answer(f"ğŸ· ğ“ğ¢ğ­ğ¥ğ : {imdb.get('title')} \n ğŸ“† ğ‘ğğ¥ğğšğ¬ğ ğˆğ§ğŸğ¨ : {imdb.get('year')} \n ğŸ“€ ğ‘ğ®ğ§ğ“ğ¢ğ¦ğ : {imdb.get('runtime')} \n â˜€ï¸ ğ‹ğšğ§ğ ğ®ğšğ ğğ¬ : {imdb.get('languages')} \n\n ğŸ¿{query.message.chat.title}ğŸ¿", show_alert=True)


    elif query.data == "sinfo":
        await query.answer(text=script.SINFO, show_alert=True)

    elif query.data == "removebg":
       await query.message.edit_text(
           text="**Select required mode**",
           reply_markup=InlineKeyboardMarkup( [[
               InlineKeyboardButton(text="ğ–¶ğ—‚ğ—ğ— ğ–¶ğ—ğ—‚ğ—ğ–¾ ğ–¡ğ–¦", callback_data="rmbgwhite"),
               InlineKeyboardButton(text="ğ–¶ğ—‚ğ—ğ—ğ—ˆğ—ğ— ğ–¡ğ–¦", callback_data="rmbgplain"),
               ],[
               InlineKeyboardButton(text="ğ–²ğ—ğ—‚ğ–¼ğ—„ğ–¾ğ—‹", callback_data="rmbgsticker"),
               ],[
               InlineKeyboardButton('ğ™±ğ™°ğ™²ğ™º', callback_data='photo')
               ]]
           )
       )
    
    elif query.data == "rmbgwhite":
        await removebg_white(client, query.message)
        
    elif query.data == "rmbgplain":
        await removebg_plain(client, query.message)
        
    elif query.data == "rmbgsticker":
        await removebg_sticker(client, query.message)
 

    elif query.data.startswith("killfilesdq"):
        ident, keyword = query.data.split("#")
        await query.message.edit_text(f"<b>Fá´‡á´›á´„ÊœÉªÉ´É¢ FÉªÊŸá´‡s Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword} á´É´ DB... PÊŸá´‡á´€sá´‡ á´¡á´€Éªá´›...</b>")
        files, total = await get_bad_files(keyword)
        await query.message.edit_text(f"<b>Fá´á´œÉ´á´… {total} FÉªÊŸá´‡s Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword} !\n\nFÉªÊŸá´‡ á´…á´‡ÊŸá´‡á´›Éªá´É´ á´˜Ê€á´á´„á´‡ss á´¡ÉªÊŸÊŸ sá´›á´€Ê€á´› ÉªÉ´ 5 sá´‡á´„á´É´á´…s!</b>")
        await asyncio.sleep(5)
        deleted = 0
        async with lock:
            try:
                for file in files:
                    file_ids = file.file_id
                    file_name = file.file_name
                    result = await Media.collection.delete_one({
                        '_id': file_ids,
                    })
                    if not result.deleted_count:
                        result = await Media2.collection.delete_one({
                            '_id': file_ids,
                        })
                    if result.deleted_count:
                        logger.info(f'FÉªÊŸá´‡ Fá´á´œÉ´á´… Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword}! Sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… {file_name} Ò“Ê€á´á´ á´…á´€á´›á´€Ê™á´€sá´‡.')
                        deleted += 1
                        if deleted % 20 == 0:
                            await query.message.edit_text(f"<b>PÊ€á´á´„á´‡ss sá´›á´€Ê€á´›á´‡á´… Ò“á´Ê€ á´…á´‡ÊŸá´‡á´›ÉªÉ´É¢ Ò“ÉªÊŸá´‡s Ò“Ê€á´á´ DB. Sá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… {str(deleted)} Ò“ÉªÊŸá´‡s Ò“Ê€á´á´ DB Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword} !\n\nPÊŸá´‡á´€sá´‡ á´¡á´€Éªá´›...</b>")
            except Exception as e:
                logger.exception(e)
                await query.message.edit_text(f'EÊ€Ê€á´Ê€: {e}')
            else:
                await query.message.edit_text(f"<b>PÊ€á´á´„á´‡ss Cá´á´á´˜ÊŸá´‡á´›á´‡á´… Ò“á´Ê€ Ò“ÉªÊŸá´‡ á´…á´‡ÊŸá´‡á´›Éªá´É´ !\n\nSá´œá´„á´„á´‡ssÒ“á´œÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… {str(deleted)} Ò“ÉªÊŸá´‡s Ò“Ê€á´á´ DB Ò“á´Ê€ Êá´á´œÊ€ á´Ì¨á´œá´‡Ê€Ê {keyword}.</b>")

               
    elif query.data.startswith("show_option"):
        ident, from_user = query.data.split("#")
#        user_id = query.message.reply_to_message.from_user.id
        reply = query.message.reply_to_message
        chat_id = query.message.chat.id
        if query.from_user.id in ADMINS:                
            permissions = ChatPermissions(can_send_messages=True)
            await query.message.chat.restrict_member(from_user, permissions)
            buttons = [[
                InlineKeyboardButton("ğŸš«ğ‚ğ¨ğ¦ğ¢ğ§ğ  ğ’ğ¨ğ¨ğ§...ğŸš«", url = "https://t.me/batchfiles_store")
            ], [
                InlineKeyboardButton("âš ï¸ ğ™²ğš•ğš˜ğšœğš ğ™³ğšŠğšğšŠ âš ï¸", callback_data="close_data")
            ]]
            reply_markup = InlineKeyboardMarkup(buttons)            
#            m = await query.message.edit_text(
#                text=f"ğ‡ğğ¥ğ¥ğ¨ {query.message.reply_to_message.from_user.mention} Huh, OK, sir! \n\n à´‡à´¨à´¿ à´†à´µàµ¼à´¤àµà´¤à´¿à´šàµà´šà´¾àµ½ à´¤àµ‚à´•àµà´•à´¿ à´à´Ÿàµà´¤àµà´¤àµ à´ªàµà´±à´¤àµà´¤àµ‡à´•àµà´•à´¿à´Ÿàµà´‚ğŸ˜¡",
#                reply_markup=reply_markup,
#                parse_mode=enums.ParseMode.HTML
#            )
            k = await query.message.reply_text(
                text=f"<b>ğ‡ğğ¥ğ¥ğ¨ {query.message.reply_to_message.from_user.mention} ğ‹ğšğ¬ğ­ ğ–ğšğ«ğ§ğ¢ğ§ğ ..\n\nà´‡à´¨à´¿ à´†à´µàµ¼à´¤àµà´¤à´¿à´šàµà´šà´¾àµ½ à´¤àµ‚à´•àµà´•à´¿ à´à´Ÿàµà´¤àµà´¤àµ à´ªàµà´±à´¤àµà´¤àµ‡à´•àµà´•à´¿à´Ÿàµà´‚ğŸ˜¡</b>",
                reply_markup=reply_markup,
                disable_web_page_preview=True,
                parse_mode=enums.ParseMode.HTML,
                reply_to_message_id=query.message.id
            )
            await asyncio.sleep(60)
            await k.delete()
            await query.answer("Há´‡Ê€á´‡ á´€Ê€á´‡ á´›Êœá´‡ á´á´˜á´›Éªá´É´s !")
        else:
            await query.answer("Yá´á´œ á´…á´É´'á´› Êœá´€á´ á´‡ sá´œÒ“Ò“Éªá´„Éªá´€É´á´› Ê€ÉªÉ¢á´›s á´›á´ á´…á´ á´›ÊœÉªs !", show_alert=True)   
 

    elif query.data.startswith("grp_checksub"):
        userid = query.message.reply_to_message.from_user.id
        if int(userid) not in [query.from_user.id, 0]:
            return await query.answer("This Is Not For You!", show_alert=True)
        if AUTH_CHANNEL and not await is_subscribed(client, query):
            await query.answer("Please join first my Updates Channel", show_alert=True)
            return
        await client.unban_chat_member(query.message.chat.id, query.from_user.id)
        await query.answer("Can You Request Now!", show_alert=True)
        permissions = ChatPermissions(can_send_messages=True)
        await query.message.chat.restrict_member(userid, permissions)
        await query.message.delete()
        await query.message.reply_to_message.delete()

    
    
    elif query.data == "world":
        try:
            reqstr1 = query.from_user.id if query.from_user else 0
            mv_rqst = query.message.reply_to_message.text
            result = await gsearch.async_search(mv_rqst)
            buttons = [[
                InlineKeyboardButton(f"ğŸ¨{result[6]['titles']}", url=f"{result[6]['links']}")
            ],[
                InlineKeyboardButton(f"ğŸŠ{result[2]['titles']}", url=f"{result[2]['links']}")
            ],[    
                InlineKeyboardButton(f"ğŸ¨{result[4]['titles']}", url=f"{result[4]['links']}")
            ],[
                InlineKeyboardButton(f"ğŸŠ{result[0]['titles']}", url=f"{result[0]['links']}")               
            ]]        
            reply_markup = InlineKeyboardMarkup(buttons)
            kd=await query.message.edit_text(
                text=f"ğğ¥ğğšğ¬ğ ğ’ğğšğ«ğœğ¡ ğ”ğ§ğšğ¯ğšğ¢ğ¥ğšğ›ğ¥ğ ğ‘ğğªğ®ğğ¬ğ­.",
                reply_markup=reply_markup,
                parse_mode=enums.ParseMode.HTML
            )
            return
        except NoResultsFound:
            await query.answer("ğŸ˜¬waiting ott release or dvd", show_alert=True)
            return
        except NoResultsOrTrafficError:
            await query.answer("ğŸ˜”waiting ott release or dvd !", show_alert=True)
            return
        except Exception as e:
            await query.answer(f"ğ–ğšğ¢ğ­ğ¢ğ§ğ  ğğ­ğ­ ğ‘ğğ¥ğğšğ¬ğ ğğ« ğƒğ¯ğ âš ï¸!", show_alert=True)
            print(f"error : {e}")
            return
            await asyncio.sleep(120)
            await kd.delete()
            await query.message.reply_to_message.delete()
         

         

    
    elif query.data == "eng":
        mv_rqst = query.message.reply_to_message.text
        buttons = [[
            InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ’ğğšğ«ğœğ¡ ğ†ğ¨ğ¨ğ ğ¥ğ{random.choice(RUN_STRINGS)}', url=f"https://www.google.com/search?q={mv_rqst}")
        ]]        
        reply_markup = InlineKeyboardMarkup(buttons)
        k=await query.message.edit_text(
            text=script.ENG.format(query.from_user.mention, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        
        await asyncio.sleep(60)
        await k.delete()

    elif query.data == "mal":
        mv_rqst = query.message.reply_to_message.text
        buttons = [[
            InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ’ğğšğ«ğœğ¡ ğ†ğ¨ğ¨ğ ğ¥ğ{random.choice(RUN_STRINGS)}', url=f"https://www.google.com/search?q={mv_rqst}")
        ]]        
        reply_markup = InlineKeyboardMarkup(buttons)
        k=await query.message.edit_text(
            text=script.MAL.format(query.from_user.mention, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        
        await asyncio.sleep(60)
        await k.delete()
       
    elif query.data == "hin":
        mv_rqst = query.message.reply_to_message.text
        buttons = [[
            InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ’ğğšğ«ğœğ¡ ğ†ğ¨ğ¨ğ ğ¥ğ{random.choice(RUN_STRINGS)}', url=f"https://www.google.com/search?q={mv_rqst}")
        ]]        
        reply_markup = InlineKeyboardMarkup(buttons)
        k=await query.message.edit_text(
            text=script.HIN.format(query.from_user.mention, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        
        await asyncio.sleep(60)
        await k.delete()

    elif query.data == "tam":
        mv_rqst = query.message.reply_to_message.text
        buttons = [[
            InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ’ğğšğ«ğœğ¡ ğ†ğ¨ğ¨ğ ğ¥ğ{random.choice(RUN_STRINGS)}', url=f"https://www.google.com/search?q={mv_rqst}")
        ]]        
        reply_markup = InlineKeyboardMarkup(buttons)
        k=await query.message.edit_text(
            text=script.TAM.format(query.from_user.mention, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        
        await asyncio.sleep(60)
        await k.delete()    

   


    elif query.data == "helps":
        buttons = [[
            InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğŒğ¨ğğ®ğ¥ğğ¬ & ğğ¥ğ®ğ ğ¢ğ§ğ¬{random.choice(RUN_STRINGS)}', callback_data='MODULES_PLUGINS')
        ], [
            InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ’ğ­ğ¢ğœğ¤ğğ« ğ…ğğšğ­ğ®ğ«ğğ¬{random.choice(RUN_STRINGS)}', callback_data='STICKERS')
        ], [
            InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğŒğğğ¢ğš ğ…ğğšğ­ğ®ğ«ğğ¬{random.choice(RUN_STRINGS)}', callback_data='MEDIA')
        ], [
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ†ğ¨ğ¨ğ ğ¥ğ & ğ‚ğ¡ğšğ­ğ†ğğ“{random.choice(RUN_STRINGS)}', callback_data='CHATGPT')
        ], [
            InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğšğ¤ğ ğ‚ğ‚ & ğ€ğğ«ğğ¬ğ¬{random.choice(RUN_STRINGS)}', callback_data='FAKECC')
        ], [
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ‡ğğ«ğ¨ğ¤ğ® ğ‚ğ®ğ¬ğ­ğšğ¦ğ¢ğ³ğ{random.choice(RUN_STRINGS)}', callback_data='HEROKU')
        ], [
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ†ğ¢ğ­ğ¡ğ®ğ› ğ‚ğ®ğ¬ğ­ğšğ¦ğ¢ğ³ğ{random.choice(RUN_STRINGS)}', callback_data='GITHUB')
        ], [
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ„ğ±ğ­ğ«ğš ğ…ğğšğ­ğ®ğ«ğğ¬{random.choice(RUN_STRINGS)}', callback_data='ADMINS_AND_PRIVATE')
        ], [
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ‡ğ¨ğ¦ğ{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]
        
        reply_markup = InlineKeyboardMarkup(buttons)
        
#        await query.edit_message_reply_markup(
#            reply_markup=InlineKeyboardMarkup(buttons)
#        )
        k=await query.message.edit_text(
            text=script.START_TXT.format(query.from_user.mention, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        
        await asyncio.sleep(60)
        await k.delete()
    
    elif query.data == "MODULES_PLUGINS":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğŒğğƒğ”ğ‹ğ„ğ’ & ğğ‹ğ”ğ†ğˆğğ’ ğŸ{random.choice(RUN_STRINGS)}', callback_data='MODULES_PLUGINS2')
        ], [
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğŒğğƒğ”ğ‹ğ„ğ’ & ğğ‹ğ”ğ†ğˆğğ’ ğŸ‘{random.choice(RUN_STRINGS)}', callback_data='MODULES_PLUGINS3')
        ], [
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')                
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.MODULES_PLUGINS.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        
    elif query.data == "MODULES_PLUGINS2":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.MODULES_PLUGINS2.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )       
    elif query.data == "MODULES_PLUGINS3":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.MODULES_PLUGINS3.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
       
    elif query.data == "MEDIA":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.MEDIA.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
  
    elif query.data == "STICKERS":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.STICKERS.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )

    elif query.data == "FAKECC":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.FAKECC.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )   

    elif query.data == "CHATGPT":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.CHATGPT.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )

    elif query.data == "GITHUB":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.GITHUB.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
    elif query.data == "HEROKU":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.HEROKU.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
    elif query.data == "ADMINS_AND_PRIVATE":
        buttons = [[
           InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğğšğœğ¤{random.choice(RUN_STRINGS)}', callback_data='helps')
        
        ]]    
        reply_markup = InlineKeyboardMarkup(buttons)
        
        await query.message.edit_text(
            text=script.ADMINS_AND_PRIVATE.format(query.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )   
    elif query.data == "stats":
        buttons = [[
            InlineKeyboardButton('âŸ¸ Bá´€á´„á´‹', callback_data='help'),
            InlineKeyboardButton('âŸ² Rá´‡Ò“Ê€á´‡sÊœ', callback_data='rfrsh')
        ]]
        await client.edit_message_media(
            query.message.chat.id, 
            query.message.id, 
            InputMediaPhoto(random.choice(PICS))
        )
        reply_markup = InlineKeyboardMarkup(buttons)
        #primary db
        totalp = await Media.count_documents()
        #secondary db
        totalsec = await Media2.count_documents()
        #users and chats
        users = await db.total_users_count()
        chats = await db.total_chat_count()
        #primary db
        stats = await clientDB.command('dbStats')
        used_dbSize = (stats['dataSize']/(1024*1024))+(stats['indexSize']/(1024*1024))
        free_dbSize = 512-used_dbSize
        #secondary db
        stats2 = await clientDB2.command('dbStats')
        used_dbSize2 = (stats2['dataSize']/(1024*1024))+(stats2['indexSize']/(1024*1024))
        free_dbSize2 = 512-used_dbSize2
        await query.message.edit_text(
            text=script.STATUS_TXT.format((int(totalp)+int(totalsec)), users, chats, totalp, round(used_dbSize, 2), round(free_dbSize, 2), totalsec, round(used_dbSize2, 2), round(free_dbSize2, 2)),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
    elif query.data == "rfrsh":
        await query.answer("Fetching MongoDb DataBase")
        buttons = [[
            InlineKeyboardButton('âŸ¸ Bá´€á´„á´‹', callback_data='help'),
            InlineKeyboardButton('âŸ² Rá´‡Ò“Ê€á´‡sÊœ', callback_data='rfrsh')
        ]]
        await client.edit_message_media(
            query.message.chat.id, 
            query.message.id, 
            InputMediaPhoto(random.choice(PICS))
        )
        reply_markup = InlineKeyboardMarkup(buttons)
        #primary db
        totalp = await Media.count_documents()
        #secondary db
        totalsec = await Media2.count_documents()
        users = await db.total_users_count()
        chats = await db.total_chat_count()
        #primary db
        stats = await clientDB.command('dbStats')
        used_dbSize = (stats['dataSize']/(1024*1024))+(stats['indexSize']/(1024*1024))
        free_dbSize = 512-used_dbSize
        #secondary db
        stats2 = await clientDB2.command('dbStats')
        used_dbSize2 = (stats2['dataSize']/(1024*1024))+(stats2['indexSize']/(1024*1024))
        free_dbSize2 = 512-used_dbSize2
        await query.message.edit_text(
            text=script.STATUS_TXT.format((int(totalp)+int(totalsec)), users, chats, totalp, round(used_dbSize, 2), round(free_dbSize, 2), totalsec, round(used_dbSize2, 2), round(free_dbSize2, 2)),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
    elif query.data == "owner_info":
            btn = [[
                    InlineKeyboardButton("âŸ¸ Bá´€á´„á´‹", callback_data="start"),
                    InlineKeyboardButton("Cá´É´á´›á´€á´„á´›", url="t.me/creatorbeatz")
                  ]]
            await client.edit_message_media(
                query.message.chat.id, 
                query.message.id, 
                InputMediaPhoto(random.choice(PICS))
            )
            reply_markup = InlineKeyboardMarkup(btn)
            await query.message.edit_text(
                text=(script.OWNER_INFO),
                reply_markup=reply_markup,
                parse_mode=enums.ParseMode.HTML
            )

    elif query.data.startswith("setgs"):
        ident, set_type, status, grp_id = query.data.split("#")
        grpid = await active_connection(str(query.from_user.id))

        if set_type == 'is_shortlink' and query.from_user.id not in ADMINS:
            return await query.answer(text=f"Há´‡Ê {query.from_user.first_name}, Yá´á´œ á´„á´€É´'á´› á´„Êœá´€É´É¢á´‡ sÊœá´Ê€á´›ÊŸÉªÉ´á´‹ sá´‡á´›á´›ÉªÉ´É¢s Ò“á´Ê€ Êá´á´œÊ€ É¢Ê€á´á´œá´˜ !\n\nIá´›'s á´€É´ á´€á´…á´ÉªÉ´ á´É´ÊŸÊ sá´‡á´›á´›ÉªÉ´É¢ !", show_alert=True)

        if str(grp_id) != str(grpid) and query.from_user.id not in ADMINS:
            await query.message.edit("Yá´á´œÊ€ Aá´„á´›Éªá´ á´‡ Cá´É´É´á´‡á´„á´›Éªá´É´ Há´€s Bá´‡á´‡É´ CÊœá´€É´É¢á´‡á´…. Gá´ Tá´ /connections á´€É´á´… á´„Êœá´€É´É¢á´‡ Êá´á´œÊ€ á´€á´„á´›Éªá´ á´‡ á´„á´É´É´á´‡á´„á´›Éªá´É´.")
            return await query.answer(MSG_ALRT)

        if status == "True":
            await save_group_settings(grpid, set_type, False)
        else:
            await save_group_settings(grpid, set_type, True)

        settings = await get_settings(grpid)

        if settings is not None:
            buttons = [
                [
                    InlineKeyboardButton('FÉªÊŸá´›á´‡Ê€ Bá´œá´›á´›á´É´',
                                         callback_data=f'setgs#button#{settings["button"]}#{str(grp_id)}'),
                    InlineKeyboardButton('SÉªÉ´É¢ÊŸá´‡' if settings["button"] else 'Dá´á´œÊ™ÊŸá´‡',
                                         callback_data=f'setgs#button#{settings["button"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('FÉªÊŸá´‡ Sá´‡É´á´… Má´á´…á´‡', callback_data=f'setgs#botpm#{settings["botpm"]}#{str(grp_id)}'),
                    InlineKeyboardButton('Má´€É´á´œá´€ÊŸ Sá´›á´€Ê€á´›' if settings["botpm"] else 'Aá´œá´›á´ Sá´‡É´á´…',
                                         callback_data=f'setgs#botpm#{settings["botpm"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('PÊ€á´á´›á´‡á´„á´› Cá´É´á´›á´‡É´á´›',
                                         callback_data=f'setgs#file_secure#{settings["file_secure"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["file_secure"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#file_secure#{settings["file_secure"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Iá´á´…Ê™', callback_data=f'setgs#imdb#{settings["imdb"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["imdb"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#imdb#{settings["imdb"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Sá´˜á´‡ÊŸÊŸ CÊœá´‡á´„á´‹',
                                         callback_data=f'setgs#spell_check#{settings["spell_check"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["spell_check"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#spell_check#{settings["spell_check"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Wá´‡ÊŸá´„á´á´á´‡ MsÉ¢', callback_data=f'setgs#welcome#{settings["welcome"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["welcome"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#welcome#{settings["welcome"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Aá´œá´›á´-Dá´‡ÊŸá´‡á´›á´‡',
                                         callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{str(grp_id)}'),
                    InlineKeyboardButton('10 MÉªÉ´s' if settings["auto_delete"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Aá´œá´›á´-FÉªÊŸá´›á´‡Ê€',
                                         callback_data=f'setgs#auto_ffilter#{settings["auto_ffilter"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["auto_ffilter"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#auto_ffilter#{settings["auto_ffilter"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('Má´€x Bá´œá´›á´›á´É´s',
                                         callback_data=f'setgs#max_btn#{settings["max_btn"]}#{str(grp_id)}'),
                    InlineKeyboardButton('10' if settings["max_btn"] else f'{MAX_B_TN}',
                                         callback_data=f'setgs#max_btn#{settings["max_btn"]}#{str(grp_id)}')
                ],
                [
                    InlineKeyboardButton('SÊœá´Ê€á´›LÉªÉ´á´‹',
                                         callback_data=f'setgs#is_shortlink#{settings["is_shortlink"]}#{str(grp_id)}'),
                    InlineKeyboardButton('âœ” OÉ´' if settings["is_shortlink"] else 'âœ˜ OÒ“Ò“',
                                         callback_data=f'setgs#is_shortlink#{settings["is_shortlink"]}#{str(grp_id)}')
                ]
            ]
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.message.edit_reply_markup(reply_markup)
    await query.answer(MSG_ALRT)

    
async def auto_filter(client, msg, spoll=False):
    curr_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
    # reqstr1 = msg.from_user.id if msg.from_user else 0
    # reqstr = await client.get_users(reqstr1)
    
    if not spoll:
        message = msg
        if message.text.startswith("/"): return  # ignore commands
        if re.findall("((^\/|^,|^!|^\.|^[\U0001F600-\U000E007F]).*)", message.text):
            return
        if len(message.text) < 100:
            search = message.text
            m=await message.reply_text(f"<b><i> ğ–²ğ–¾ğ–ºğ—‹ğ–¼ğ—ğ—‚ğ—‡ğ—€ ğ–¿ğ—ˆğ—‹ '{search}' ğŸ”</i></b>")
            search = search.lower()
            find = search.split(" ")
            search = ""
            removes = ["in","upload", "series", "full", "horror", "thriller", "mystery", "print", "file"]
            for x in find:
                if x in removes:
                    continue
                else:
                    search = search + x + " "
            search = re.sub(r"\b(pl(i|e)*?(s|z+|ease|se|ese|(e+)s(e)?)|((send|snd|giv(e)?|gib)(\sme)?)|movie(s)?|new|latest|bro|bruh|broh|helo|that|find|dubbed|link|venum|iruka|pannunga|pannungga|anuppunga|anupunga|anuppungga|anupungga|film|undo|kitti|kitty|tharu|kittumo|kittum|movie|any(one)|with\ssubtitle(s)?)", "", search, flags=re.IGNORECASE)
            search = re.sub(r"\s+", " ", search).strip()
            search = search.replace("-", " ")
            search = search.replace(":","")
            files, offset, total_results = await get_search_results(message.chat.id ,search, offset=0, filter=True)
            settings = await get_settings(message.chat.id)
            if not files:
                await m.delete()
                if settings["spell_check"]:
                    return await advantage_spell_chok(client, msg)
                else:
                    # if NO_RESULTS_MSG:
                    #     await client.send_message(chat_id=LOG_CHANNEL, text=(script.NORSLTS.format(reqstr.id, reqstr.mention, search)))
                    return
        else:
            return
    else:
        message = msg.message.reply_to_message  # msg will be callback query
        search, files, offset, total_results = spoll
        settings = await get_settings(message.chat.id)
        
    temp.SEND_ALL_TEMP[message.from_user.id] = files
    temp.KEYWORD[message.from_user.id] = search
    if 'is_shortlink' in settings.keys():
        ENABLE_SHORTLINK = settings['is_shortlink']
    else:
        await save_group_settings(message.chat.id, 'is_shortlink', False)
        ENABLE_SHORTLINK = False
    pre = 'filep' if settings['file_secure'] else 'file'
    if ENABLE_SHORTLINK and settings["button"]:
        btn = [
            [
                InlineKeyboardButton(
                    text=f"ğŸ“¥[{get_size(file.file_size)}] {' '.join(filter(lambda x: not x.startswith('[') and not x.startswith('@') and not x.startswith('www.'), file.file_name.split()))}", callback_data=f'{pre}#{file.file_id}'
                ),
            ]
            for file in files 
                  
        ]
        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"send_fall#{pre}#{0}#{message.from_user.id}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{message.from_user.id}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{message.from_user.id}")
        ])
    else:
        btn = []
        btn.insert(0, 
            [
                InlineKeyboardButton(f'{random.choice(RUN_STRINGS)}ğ…ğ¢ğ¥ğğ¬ ğˆğ§ğŸğ¨', 'select'),
                InlineKeyboardButton(f"ğŒğ¨ğ¯ğ¢ğ ğˆğ§ğŸğ¨{random.choice(RUN_STRINGS)}", 'update')
            ]
        )
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ’ğğ§ğ ğ€ğ¥ğ¥", callback_data=f"send_fall#{pre}#{0}#{message.from_user.id}"),
            InlineKeyboardButton(f"ğğ®ğšğ¥ğ¢ğ­ğ²{random.choice(RUN_STRINGS)}", callback_data=f"quality")
        ])
        btn.insert(0, [
            InlineKeyboardButton(f"{random.choice(RUN_STRINGS)}ğ‹ğšğ§ğ ğ®ğšğ ğğ¬", callback_data=f"languages#{message.from_user.id}"),
            InlineKeyboardButton(f"ğ’ğğšğ¬ğ¨ğ§ğ¬{random.choice(RUN_STRINGS)}",  callback_data=f"seasons#{message.from_user.id}")
        ])
    if offset != "":
        req = message.from_user.id if message.from_user else 0
        try:
            if settings['max_btn']:
                btn.append(
                    [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/10)}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
                )
            else:
                btn.append(
                    [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/int(MAX_B_TN))}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
                )
        except KeyError:
            await save_group_settings(message.chat.id, 'max_btn', True)
            btn.append(
                [InlineKeyboardButton("ğğ€ğ†ğ„", callback_data="pages"), InlineKeyboardButton(text=f"1/{math.ceil(int(total_results)/10)}",callback_data="pages"), InlineKeyboardButton(text="ğğ„ğ—ğ“ âª",callback_data=f"next_{req}_{key}_{offset}")]
            )
    else:
        btn.append(
            [InlineKeyboardButton(text="ğğ ğŒğğ‘ğ„ ğğ€ğ†ğ„ğ’ ğ€ğ•ğ€ğˆğ‹ğ€ğğ‹ğ„",callback_data="pages")]
        )
    imdb = await get_poster(search, file=(files[0]).file_name) if settings["imdb"] else None
    cur_time = datetime.now(pytz.timezone('Asia/Kolkata')).time()
    time_difference = timedelta(hours=cur_time.hour, minutes=cur_time.minute, seconds=(cur_time.second+(cur_time.microsecond/1000000))) - timedelta(hours=curr_time.hour, minutes=curr_time.minute, seconds=(curr_time.second+(curr_time.microsecond/1000000)))
    remaining_seconds = "{:.2f}".format(time_difference.total_seconds())
    TEMPLATE = script.IMDB_TEMPLATE_TXT
    if imdb:
        cap = TEMPLATE.format(
            qurey=search,
            title=imdb['title'],
            votes=imdb['votes'],
            aka=imdb["aka"],
            seasons=imdb["seasons"],
            box_office=imdb['box_office'],
            localized_title=imdb['localized_title'],
            kind=imdb['kind'],
            imdb_id=imdb["imdb_id"],
            cast=imdb["cast"],
            runtime=imdb["runtime"],
            countries=imdb["countries"],
            certificates=imdb["certificates"],
            languages=imdb["languages"],
            director=imdb["director"],
            writer=imdb["writer"],
            producer=imdb["producer"],
            composer=imdb["composer"],
            cinematographer=imdb["cinematographer"],
            music_team=imdb["music_team"],
            distributors=imdb["distributors"],
            release_date=imdb['release_date'],
            year=imdb['year'],
            genres=imdb['genres'],
            poster=imdb['poster'],
            plot=imdb['plot'],
            rating=imdb['rating'],
            url=imdb['url'],
            **locals()
        )
        temp.IMDB_CAP[message.from_user.id] = cap
        if not settings["button"]:
            cap+=f"<b>\n\n<u>{random.choice(RUN_STRINGS)} ğ‘ğğªğ®ğğ¬ğ­ğğ ğ…ğ¢ğ¥ğğ¬ ğŸ‘‡</u></b>\n"
            for file in files:
                cap += f"<b>\n{random.choice(RUN_STRINGS)} <a href='https://telegram.me/{temp.U_NAME}?start=files_{file.file_id}'>[{get_size(file.file_size)}] {' '.join(filter(lambda x: not x.startswith('[') and not x.startswith('@') and not x.startswith('www.'), file.file_name.split()))}\n</a></b>"
    else:
        if settings["button"]:
            cap = f"<b>TÊœá´‡ Rá´‡êœ±á´œÊŸá´›êœ± Fá´Ê€ â˜ {search}\n\nRá´‡Ç«á´œá´‡sá´›á´‡á´… BÊ â˜ {message.from_user.mention}\n\nÊ€á´‡sá´œÊŸá´› sÊœá´á´¡ ÉªÉ´ â˜ {remaining_seconds} sá´‡á´„á´É´á´…s\n\ná´˜á´á´¡á´‡Ê€á´‡á´… Ê™Ê â˜ : {message.chat.title} \n\nâš ï¸ á´€êœ°á´›á´‡Ê€ 5 á´ÉªÉ´á´œá´›á´‡êœ± á´›ÊœÉªêœ± á´á´‡êœ±êœ±á´€É¢á´‡ á´¡ÉªÊŸÊŸ Ê™á´‡ á´€á´œá´›á´á´á´€á´›Éªá´„á´€ÊŸÊŸÊ á´…á´‡ÊŸá´‡á´›á´‡á´… ğŸ—‘ï¸\n\n</b>"
        else:
            cap = f"<b>Há´‡Ê {message.from_user.mention}, Fá´á´œÉ´á´… {total_results} Rá´‡sá´œÊŸá´›s Ò“á´Ê€ Yá´á´œÊ€ Qá´œá´‡Ê€Ê {search}\n\n</b>"
            cap+="<b><u>{random.choice(RUN_STRINGS)} ğ‘ğğªğ®ğğ¬ğ­ğğ ğ…ğ¢ğ¥ğğ¬ ğŸ‘‡</u></b>\n\n"
            for file in files:
                cap += f"<b>{random.choice(RUN_STRINGS)} <a href='https://telegram.me/{temp.U_NAME}?start=files_{file.file_id}'>[{get_size(file.file_size)}] {' '.join(filter(lambda x: not x.startswith('[') and not x.startswith('@') and not x.startswith('www.'), file.file_name.split()))}\n\n</a></b>"

    if imdb and imdb.get('poster'):
        try:
            hehe = await message.reply_photo(photo=imdb.get('poster'), caption=cap, reply_markup=InlineKeyboardMarkup(btn))
            await m.delete()
            try:
                if settings['auto_delete']:
                    await asyncio.sleep(300)
                    await hehe.delete()
                    await message.delete()
            except KeyError:
                await save_group_settings(message.chat.id, 'auto_delete', True)
                await asyncio.sleep(300)
                await hehe.delete()
                await message.delete()
        except (MediaEmpty, PhotoInvalidDimensions, WebpageMediaEmpty):
            pic = imdb.get('poster')
            poster = pic.replace('.jpg', "._V1_UX360.jpg") 
            hmm = await message.reply_photo(photo=poster, caption=cap, reply_markup=InlineKeyboardMarkup(btn))
            await m.delete()
            try:
               if settings['auto_delete']:
                    await asyncio.sleep(300)
                    m=await message.reply_text("ğŸ”")
                    await hmm.delete()
                    await message.delete()
            except KeyError:
                await save_group_settings(message.chat.id, 'auto_delete', True)
                await asyncio.sleep(300)
                await hmm.delete()
                await message.delete()
        except Exception as e:
            logger.exception(e)
            m=await message.reply_text("ğŸ”") 
            fek = await message.reply_text(text=cap, reply_markup=InlineKeyboardMarkup(btn))
            await m.delete()
            try:
                if settings['auto_delete']:
                    await asyncio.sleep(300)
                    await fek.delete()
                    await message.delete()
            except KeyError:
                await save_group_settings(message.chat.id, 'auto_delete', True)
                await asyncio.sleep(300)
                await fek.delete()
                await message.delete()
    else:
        fuk = await message.reply_text(text=cap, reply_markup=InlineKeyboardMarkup(btn), disable_web_page_preview=True)
        await m.delete()
        try:
            if settings['auto_delete']:
                await asyncio.sleep(300)
                await fuk.delete()
                await message.delete()
        except KeyError:
            await save_group_settings(message.chat.id, 'auto_delete', True)
            await asyncio.sleep(300)
            await fuk.delete()
            await message.delete()


async def advantage_spell_chok(client, msg):
    mv_id = msg.id
    mv_rqst = msg.text
    reqstr1 = msg.from_user.id if msg.from_user else 0
    reqstr = await client.get_users(reqstr1)
    settings = await get_settings(msg.chat.id)
    query = re.sub(
        r"\b(pl(i|e)*?(s|z+|ease|se|ese|(e+)s(e)?)|((send|snd|giv(e)?|gib)(\sme)?)|movie(s)?|new|latest|br((o|u)h?)*|^h(e|a)?(l)*(o)*|mal(ayalam)?|t(h)?amil|file|that|find|und(o)*|kit(t(i|y)?)?o(w)?|thar(u)?(o)*w?|kittum(o)*|aya(k)*(um(o)*)?|full\smovie|any(one)|with\ssubtitle(s)?)",
        "", msg.text, flags=re.IGNORECASE)  # plis contribute some common words
    query = query.strip() + " movie"
    try:
        movies = await get_poster(mv_rqst, bulk=True)
    except Exception as e:
        logger.exception(e)
        reqst_gle = mv_rqst.replace(" ", "+")
        button = [[
                   InlineKeyboardButton("Gá´á´É¢ÊŸá´‡", url=f"https://www.google.com/search?q={reqst_gle}")
        ]]
        if NO_RESULTS_MSG:
            await client.send_message(chat_id=LOG_CHANNEL, text=(script.NORSLTS.format(reqstr.id, reqstr.mention, mv_rqst)))
        k = await msg.reply_photo(
            photo=SPELL_IMG, 
            caption=script.I_CUDNT.format(mv_rqst),
            reply_markup=InlineKeyboardMarkup(button)
        )
        await asyncio.sleep(30)
        await k.delete()
        return
    movielist = []
    if not movies:
        reqst_gle = mv_rqst.replace(" ", "+")
        button = [[
                   InlineKeyboardButton("Gá´á´É¢ÊŸá´‡", url=f"https://www.google.com/search?q={reqst_gle}")
        ]]
        if NO_RESULTS_MSG:
            await client.send_message(chat_id=LOG_CHANNEL, text=(script.NORSLTS.format(reqstr.id, reqstr.mention, mv_rqst)))
        k = await msg.reply_photo(
            photo=SPELL_IMG, 
            caption=script.I_CUDNT.format(mv_rqst),
            reply_markup=InlineKeyboardMarkup(button)
        )
        await asyncio.sleep(30)
        await k.delete()
        return
    movielist += [movie.get('title') for movie in movies]
    movielist += [f"{movie.get('title')} {movie.get('year')}" for movie in movies]
    SPELL_CHECK[mv_id] = movielist
    btn = [
        [
            InlineKeyboardButton(
                text=movie_name.strip(),
                callback_data=f"spol#{reqstr1}#{k}",
            )
        ]
        for k, movie_name in enumerate(movielist)
    ]
    btn.append([InlineKeyboardButton(text="Close", callback_data=f'spol#{reqstr1}#close_spellcheck')])
    spell_check_del = await msg.reply_photo(
        photo=(SPELL_IMG),
        caption=(script.CUDNT_FND.format(mv_rqst)),
        reply_markup=InlineKeyboardMarkup(btn)
    )
    try:
        if settings['auto_delete']:
            await asyncio.sleep(600)
            await spell_check_del.delete()
    except KeyError:
            grpid = await active_connection(str(msg.from_user.id))
            await save_group_settings(grpid, 'auto_delete', True)
            settings = await get_settings(msg.chat.id)
            if settings['auto_delete']:
                await asyncio.sleep(600)
                await spell_check_del.delete()


async def manual_filters(client, message, text=False):
    settings = await get_settings(message.chat.id)
    group_id = message.chat.id
    name = text or message.text
    reply_id = message.reply_to_message.id if message.reply_to_message else message.id
    keywords = await get_filters(group_id)
    for keyword in reversed(sorted(keywords, key=len)):
        pattern = r"( |^|[^\w])" + re.escape(keyword) + r"( |$|[^\w])"
        if re.search(pattern, name, flags=re.IGNORECASE):
            reply_text, btn, alert, fileid = await find_filter(group_id, keyword)

            if reply_text:
                reply_text = reply_text.replace("\\n", "\n").replace("\\t", "\t")

            if btn is not None:
                try:
                    if fileid == "None":
                        if btn == "[]":
                            joelkb = await client.send_message(
                                group_id, 
                                reply_text, 
                                disable_web_page_preview=True,
                                protect_content=True if settings["file_secure"] else False,
                                reply_to_message_id=reply_id
                            )
                            try:
                                if settings['auto_ffilter']:
                                    await auto_filter(client, message)
                                    try:
                                        if settings['auto_delete']:
                                            await joelkb.delete()
                                    except KeyError:
                                        grpid = await active_connection(str(message.from_user.id))
                                        await save_group_settings(grpid, 'auto_delete', True)
                                        settings = await get_settings(message.chat.id)
                                        if settings['auto_delete']:
                                            await joelkb.delete()
                                else:
                                    try:
                                        if settings['auto_delete']:
                                            await asyncio.sleep(600)
                                            await joelkb.delete()
                                    except KeyError:
                                        grpid = await active_connection(str(message.from_user.id))
                                        await save_group_settings(grpid, 'auto_delete', True)
                                        settings = await get_settings(message.chat.id)
                                        if settings['auto_delete']:
                                            await asyncio.sleep(600)
                                            await joelkb.delete()
                            except KeyError:
                                grpid = await active_connection(str(message.from_user.id))
                                await save_group_settings(grpid, 'auto_ffilter', True)
                                settings = await get_settings(message.chat.id)
                                if settings['auto_ffilter']:
                                    await auto_filter(client, message)

                        else:
                            button = eval(btn)
                            joelkb = await client.send_message(
                                group_id,
                                reply_text,
                                disable_web_page_preview=True,
                                reply_markup=InlineKeyboardMarkup(button),
                                protect_content=True if settings["file_secure"] else False,
                                reply_to_message_id=reply_id
                            )
                            try:
                                if settings['auto_ffilter']:
                                    await auto_filter(client, message)
                                    try:
                                        if settings['auto_delete']:
                                            await joelkb.delete()
                                    except KeyError:
                                        grpid = await active_connection(str(message.from_user.id))
                                        await save_group_settings(grpid, 'auto_delete', True)
                                        settings = await get_settings(message.chat.id)
                                        if settings['auto_delete']:
                                            await joelkb.delete()
                                else:
                                    try:
                                        if settings['auto_delete']:
                                            await asyncio.sleep(600)
                                            await joelkb.delete()
                                    except KeyError:
                                        grpid = await active_connection(str(message.from_user.id))
                                        await save_group_settings(grpid, 'auto_delete', True)
                                        settings = await get_settings(message.chat.id)
                                        if settings['auto_delete']:
                                            await asyncio.sleep(600)
                                            await joelkb.delete()
                            except KeyError:
                                grpid = await active_connection(str(message.from_user.id))
                                await save_group_settings(grpid, 'auto_ffilter', True)
                                settings = await get_settings(message.chat.id)
                                if settings['auto_ffilter']:
                                    await auto_filter(client, message)

                    elif btn == "[]":
                        joelkb = await client.send_cached_media(
                            group_id,
                            fileid,
                            caption=reply_text or "",
                            protect_content=True if settings["file_secure"] else False,
                            reply_to_message_id=reply_id
                        )
                        try:
                            if settings['auto_ffilter']:
                                await auto_filter(client, message)
                                try:
                                    if settings['auto_delete']:
                                        await joelkb.delete()
                                except KeyError:
                                    grpid = await active_connection(str(message.from_user.id))
                                    await save_group_settings(grpid, 'auto_delete', True)
                                    settings = await get_settings(message.chat.id)
                                    if settings['auto_delete']:
                                        await joelkb.delete()
                            else:
                                try:
                                    if settings['auto_delete']:
                                        await asyncio.sleep(600)
                                        await joelkb.delete()
                                except KeyError:
                                    grpid = await active_connection(str(message.from_user.id))
                                    await save_group_settings(grpid, 'auto_delete', True)
                                    settings = await get_settings(message.chat.id)
                                    if settings['auto_delete']:
                                        await asyncio.sleep(600)
                                        await joelkb.delete()
                        except KeyError:
                            grpid = await active_connection(str(message.from_user.id))
                            await save_group_settings(grpid, 'auto_ffilter', True)
                            settings = await get_settings(message.chat.id)
                            if settings['auto_ffilter']:
                                await auto_filter(client, message)

                    else:
                        button = eval(btn)
                        joelkb = await message.reply_cached_media(
                            fileid,
                            caption=reply_text or "",
                            reply_markup=InlineKeyboardMarkup(button),
                            reply_to_message_id=reply_id
                        )
                        try:
                            if settings['auto_ffilter']:
                                await auto_filter(client, message)
                                try:
                                    if settings['auto_delete']:
                                        await joelkb.delete()
                                except KeyError:
                                    grpid = await active_connection(str(message.from_user.id))
                                    await save_group_settings(grpid, 'auto_delete', True)
                                    settings = await get_settings(message.chat.id)
                                    if settings['auto_delete']:
                                        await joelkb.delete()
                            else:
                                try:
                                    if settings['auto_delete']:
                                        await asyncio.sleep(600)
                                        await joelkb.delete()
                                except KeyError:
                                    grpid = await active_connection(str(message.from_user.id))
                                    await save_group_settings(grpid, 'auto_delete', True)
                                    settings = await get_settings(message.chat.id)
                                    if settings['auto_delete']:
                                        await asyncio.sleep(600)
                                        await joelkb.delete()
                        except KeyError:
                            grpid = await active_connection(str(message.from_user.id))
                            await save_group_settings(grpid, 'auto_ffilter', True)
                            settings = await get_settings(message.chat.id)
                            if settings['auto_ffilter']:
                                await auto_filter(client, message)

                except Exception as e:
                    logger.exception(e)
                break
    else:
        return False

async def global_filters(client, message, text=False):
    settings = await get_settings(message.chat.id)
    group_id = message.chat.id
    name = text or message.text
    reply_id = message.reply_to_message.id if message.reply_to_message else message.id
    keywords = await get_gfilters('gfilters')
    for keyword in reversed(sorted(keywords, key=len)):
        pattern = r"( |^|[^\w])" + re.escape(keyword) + r"( |$|[^\w])"
        if re.search(pattern, name, flags=re.IGNORECASE):
            reply_text, btn, alert, fileid = await find_gfilter('gfilters', keyword)

            if reply_text:
                reply_text = reply_text.replace("\\n", "\n").replace("\\t", "\t")

            if btn is not None:
                try:
                    if fileid == "None":
                        if btn == "[]":
                            joelkb = await client.send_message(
                                group_id, 
                                reply_text, 
                                disable_web_page_preview=True,
                                reply_to_message_id=reply_id
                            )
                            manual = await manual_filters(client, message)
                            if manual == False:
                                settings = await get_settings(message.chat.id)
                                try:
                                    if settings['auto_ffilter']:
                                        await auto_filter(client, message)
                                        try:
                                            if settings['auto_delete']:
                                                await joelkb.delete()
                                        except KeyError:
                                            grpid = await active_connection(str(message.from_user.id))
                                            await save_group_settings(grpid, 'auto_delete', True)
                                            settings = await get_settings(message.chat.id)
                                            if settings['auto_delete']:
                                                await joelkb.delete()
                                    else:
                                        try:
                                            if settings['auto_delete']:
                                                await asyncio.sleep(600)
                                                await joelkb.delete()
                                        except KeyError:
                                            grpid = await active_connection(str(message.from_user.id))
                                            await save_group_settings(grpid, 'auto_delete', True)
                                            settings = await get_settings(message.chat.id)
                                            if settings['auto_delete']:
                                                await asyncio.sleep(600)
                                                await joelkb.delete()
                                except KeyError:
                                    grpid = await active_connection(str(message.from_user.id))
                                    await save_group_settings(grpid, 'auto_ffilter', True)
                                    settings = await get_settings(message.chat.id)
                                    if settings['auto_ffilter']:
                                        await auto_filter(client, message) 
                            else:
                                try:
                                    if settings['auto_delete']:
                                        await joelkb.delete()
                                except KeyError:
                                    grpid = await active_connection(str(message.from_user.id))
                                    await save_group_settings(grpid, 'auto_delete', True)
                                    settings = await get_settings(message.chat.id)
                                    if settings['auto_delete']:
                                        await joelkb.delete()
                            
                        else:
                            button = eval(btn)
                            joelkb = await client.send_message(
                                group_id,
                                reply_text,
                                disable_web_page_preview=True,
                                reply_markup=InlineKeyboardMarkup(button),
                                reply_to_message_id=reply_id
                            )
                            manual = await manual_filters(client, message)
                            if manual == False:
                                settings = await get_settings(message.chat.id)
                                try:
                                    if settings['auto_ffilter']:
                                        await auto_filter(client, message)
                                        try:
                                            if settings['auto_delete']:
                                                await joelkb.delete()
                                        except KeyError:
                                            grpid = await active_connection(str(message.from_user.id))
                                            await save_group_settings(grpid, 'auto_delete', True)
                                            settings = await get_settings(message.chat.id)
                                            if settings['auto_delete']:
                                                await joelkb.delete()
                                    else:
                                        try:
                                            if settings['auto_delete']:
                                                await asyncio.sleep(600)
                                                await joelkb.delete()
                                        except KeyError:
                                            grpid = await active_connection(str(message.from_user.id))
                                            await save_group_settings(grpid, 'auto_delete', True)
                                            settings = await get_settings(message.chat.id)
                                            if settings['auto_delete']:
                                                await asyncio.sleep(600)
                                                await joelkb.delete()
                                except KeyError:
                                    grpid = await active_connection(str(message.from_user.id))
                                    await save_group_settings(grpid, 'auto_ffilter', True)
                                    settings = await get_settings(message.chat.id)
                                    if settings['auto_ffilter']:
                                        await auto_filter(client, message) 
                            else:
                                try:
                                    if settings['auto_delete']:
                                        await joelkb.delete()
                                except KeyError:
                                    grpid = await active_connection(str(message.from_user.id))
                                    await save_group_settings(grpid, 'auto_delete', True)
                                    settings = await get_settings(message.chat.id)
                                    if settings['auto_delete']:
                                        await joelkb.delete()

                    elif btn == "[]":
                        joelkb = await client.send_cached_media(
                            group_id,
                            fileid,
                            caption=reply_text or "",
                            reply_to_message_id=reply_id
                        )
                        manual = await manual_filters(client, message)
                        if manual == False:
                            settings = await get_settings(message.chat.id)
                            try:
                                if settings['auto_ffilter']:
                                    await auto_filter(client, message)
                                    try:
                                        if settings['auto_delete']:
                                            await joelkb.delete()
                                    except KeyError:
                                        grpid = await active_connection(str(message.from_user.id))
                                        await save_group_settings(grpid, 'auto_delete', True)
                                        settings = await get_settings(message.chat.id)
                                        if settings['auto_delete']:
                                            await joelkb.delete()
                                else:
                                    try:
                                        if settings['auto_delete']:
                                            await asyncio.sleep(600)
                                            await joelkb.delete()
                                    except KeyError:
                                        grpid = await active_connection(str(message.from_user.id))
                                        await save_group_settings(grpid, 'auto_delete', True)
                                        settings = await get_settings(message.chat.id)
                                        if settings['auto_delete']:
                                            await asyncio.sleep(600)
                                            await joelkb.delete()
                            except KeyError:
                                grpid = await active_connection(str(message.from_user.id))
                                await save_group_settings(grpid, 'auto_ffilter', True)
                                settings = await get_settings(message.chat.id)
                                if settings['auto_ffilter']:
                                    await auto_filter(client, message) 
                        else:
                            try:
                                if settings['auto_delete']:
                                    await joelkb.delete()
                            except KeyError:
                                grpid = await active_connection(str(message.from_user.id))
                                await save_group_settings(grpid, 'auto_delete', True)
                                settings = await get_settings(message.chat.id)
                                if settings['auto_delete']:
                                    await joelkb.delete()

                    else:
                        button = eval(btn)
                        joelkb = await message.reply_cached_media(
                            fileid,
                            caption=reply_text or "",
                            reply_markup=InlineKeyboardMarkup(button),
                            reply_to_message_id=reply_id
                        )
                        manual = await manual_filters(client, message)
                        if manual == False:
                            settings = await get_settings(message.chat.id)
                            try:
                                if settings['auto_ffilter']:
                                    await auto_filter(client, message)
                                    try:
                                        if settings['auto_delete']:
                                            await joelkb.delete()
                                    except KeyError:
                                        grpid = await active_connection(str(message.from_user.id))
                                        await save_group_settings(grpid, 'auto_delete', True)
                                        settings = await get_settings(message.chat.id)
                                        if settings['auto_delete']:
                                            await joelkb.delete()
                                else:
                                    try:
                                        if settings['auto_delete']:
                                            await asyncio.sleep(600)
                                            await joelkb.delete()
                                    except KeyError:
                                        grpid = await active_connection(str(message.from_user.id))
                                        await save_group_settings(grpid, 'auto_delete', True)
                                        settings = await get_settings(message.chat.id)
                                        if settings['auto_delete']:
                                            await asyncio.sleep(600)
                                            await joelkb.delete()
                            except KeyError:
                                grpid = await active_connection(str(message.from_user.id))
                                await save_group_settings(grpid, 'auto_ffilter', True)
                                settings = await get_settings(message.chat.id)
                                if settings['auto_ffilter']:
                                    await auto_filter(client, message) 
                        else:
                            try:
                                if settings['auto_delete']:
                                    await joelkb.delete()
                            except KeyError:
                                grpid = await active_connection(str(message.from_user.id))
                                await save_group_settings(grpid, 'auto_delete', True)
                                settings = await get_settings(message.chat.id)
                                if settings['auto_delete']:
                                    await joelkb.delete()

                except Exception as e:
                    logger.exception(e)
                break
    else:
        return False
